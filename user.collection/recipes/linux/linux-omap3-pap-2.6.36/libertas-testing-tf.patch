diff -urN git//drivers/net/wireless/Kconfig git-mod//drivers/net/wireless/Kconfig
--- git//drivers/net/wireless/Kconfig	2012-01-31 07:11:47.824707348 +0100
+++ git-mod//drivers/net/wireless/Kconfig	2012-01-31 07:18:22.572703875 +0100
@@ -45,6 +45,16 @@
 	---help---
 	  Debugging support.
 
+config LIBERTAS_THINFIRM_SDIO
+	tristate "Marvell Libertas 8686 SDIO 802.11b/g cards"
+	depends on LIBERTAS_THINFIRM && MMC
+	---help---
+	  A driver for Marvell Libertas 8686 SDIO devices and those that include
+	  the 88W8686 core, such as the Wi2Wi devices.  Special SDIO specific
+	  firmware is required to use this driver, see the OLPC site for details:
+
+	  <http://wiki.laptop.org/go/Thinfirm_1.5>
+
 config LIBERTAS_THINFIRM_USB
 	tristate "Marvell Libertas 8388 USB 802.11b/g cards with thin firmware"
 	depends on LIBERTAS_THINFIRM && USB

diff -urN git//drivers/net/wireless/libertas_tf/cmd.c git-mod//drivers/net/wireless/libertas_tf/cmd.c
--- git//drivers/net/wireless/libertas_tf/cmd.c	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/cmd.c	2012-01-31 07:15:13.700705536 +0100
@@ -101,7 +101,7 @@
 	priv->fwrelease = (priv->fwrelease << 8) |
 		(priv->fwrelease >> 24 & 0xff);
 
-	printk(KERN_INFO "libertastf: %pM, fw %u.%u.%up%u, cap 0x%08x\n",
+	printk(KERN_INFO "libertas_tf: %pM, fw %u.%u.%up%u, cap 0x%08x\n",
 		cmd.permanentaddr,
 		priv->fwrelease >> 24 & 0xff,
 		priv->fwrelease >> 16 & 0xff,
@@ -252,7 +252,7 @@
 
 	lbtf_deb_cmd("DNLD_CMD: command 0x%04x, seq %d, size %d\n",
 		     command, le16_to_cpu(cmd->seqnum), cmdsize);
-	lbtf_deb_hex(LBTF_DEB_CMD, "DNLD_CMD", (void *) cmdnode->cmdbuf, cmdsize);
+	lbtf_deb_hex(LBTF_DEB_CMD, "DNLD_CMD ", (void *) cmdnode->cmdbuf, cmdsize);
 
 	ret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) cmd, cmdsize);
 	spin_unlock_irqrestore(&priv->driver_lock, flags);
@@ -347,6 +347,7 @@
 	lbtf_deb_wext("Switching to mode: 0x%x\n", mode);
 	lbtf_cmd_async(priv, CMD_802_11_SET_MODE, &cmd.hdr, sizeof(cmd));
 
+	priv->mode = mode;
 	lbtf_deb_leave(LBTF_DEB_WEXT);
 }
 
@@ -354,7 +355,7 @@
 {
 	struct cmd_ds_set_bssid cmd;
 	lbtf_deb_enter(LBTF_DEB_CMD);
-
+	lbtf_deb_cmd("Set BSSID: %pM a: %d", bssid, activate);
 	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
 	cmd.activate = activate ? 1 : 0;
 	if (activate)
@@ -364,13 +365,13 @@
 	lbtf_deb_leave(LBTF_DEB_CMD);
 }
 
-int lbtf_set_mac_address(struct lbtf_private *priv, uint8_t *mac_addr)
+int _lbtf_change_mac_address(struct lbtf_private *priv, uint8_t *mac_addr, int action)
 {
 	struct cmd_ds_802_11_mac_address cmd;
 	lbtf_deb_enter(LBTF_DEB_CMD);
 
 	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
-	cmd.action = cpu_to_le16(CMD_ACT_SET);
+	cmd.action = cpu_to_le16(action);
 
 	memcpy(cmd.macadd, mac_addr, ETH_ALEN);
 
@@ -379,6 +380,21 @@
 	return 0;
 }
 
+int lbtf_set_mac_address(struct lbtf_private *priv, uint8_t *mac_addr)
+{
+	return _lbtf_change_mac_address( priv, mac_addr, CMD_ACT_SET );
+}
+
+int lbtf_add_mac_address(struct lbtf_private *priv, uint8_t *mac_addr)
+{
+	return _lbtf_change_mac_address( priv, mac_addr, CMD_ACT_ADD );
+}
+
+int lbtf_remove_mac_address(struct lbtf_private *priv, uint8_t *mac_addr)
+{
+	return _lbtf_change_mac_address( priv, mac_addr, CMD_ACT_REMOVE );
+}
+
 int lbtf_set_radio_control(struct lbtf_private *priv)
 {
 	int ret = 0;
@@ -672,6 +688,12 @@
 
 	lbtf_deb_enter(LBTF_DEB_HOST);
 
+	if (priv->surpriseremoved) {
+		lbtf_deb_host("CMD: card removed\n");
+		cmdnode = ERR_PTR(-ENOENT);
+		goto done;
+	}
+
 	cmdnode = __lbtf_cmd_async(priv, command, in_cmd, in_cmd_size,
 				  callback, callback_arg);
 	if (IS_ERR(cmdnode)) {
@@ -735,10 +757,13 @@
 	respcmd = le16_to_cpu(resp->command);
 	result = le16_to_cpu(resp->result);
 
+#ifdef CONFIG_LIBERTAS_THINFIRM_DEBUG
 	if (net_ratelimit())
-		pr_info("libertastf: cmd response 0x%04x, seq %d, size %d\n",
+		pr_info("libertastf: cmd response 0x%04x, seq %d, size %d, result %d\n",
 			respcmd, le16_to_cpu(resp->seqnum),
-			le16_to_cpu(resp->size));
+			le16_to_cpu(resp->size),
+			result);
+#endif
 
 	if (resp->seqnum != priv->cur_cmd->cmdbuf->seqnum) {
 		spin_unlock_irqrestore(&priv->driver_lock, flags);
diff -urN git//drivers/net/wireless/libertas_tf/deb_defs.h git-mod//drivers/net/wireless/libertas_tf/deb_defs.h
--- git//drivers/net/wireless/libertas_tf/deb_defs.h	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/deb_defs.h	2012-01-31 07:15:13.700705536 +0100
@@ -3,7 +3,7 @@
   * global variable declaration.
   */
 #ifndef _LBS_DEB_DEFS_H_
-#define _LBS_DEB_EFS_H_
+#define _LBS_DEB_DEFS_H_
 
 #ifndef DRV_NAME
 #define DRV_NAME "libertas_tf"
@@ -11,6 +11,9 @@
 
 #include <linux/spinlock.h>
 
+#undef pr_fmt
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
 #ifdef CONFIG_LIBERTAS_THINFIRM_DEBUG
 #define DEBUG
 #define PROC_DEBUG
@@ -40,6 +43,9 @@
 #define LBTF_DEB_HEX	0x00200000
 #define LBTF_DEB_SDIO	0x00400000
 #define LBTF_DEB_MACOPS	0x00800000
+#define LBTF_DEB_STATS	0x01000000
+#define LBTF_DEB_INT    0x02000000
+#define LBTF_DEB_SCRATCH 0x04000000
 
 extern unsigned int lbtf_debug;
 
@@ -82,8 +88,10 @@
 #define lbtf_deb_usbd(dev, fmt, args...) LBTF_DEB_LL(LBTF_DEB_USB, " usbd", "%s:" fmt, dev_name(dev), ##args)
 #define lbtf_deb_cs(fmt, args...)        LBTF_DEB_LL(LBTF_DEB_CS, " cs", fmt, ##args)
 #define lbtf_deb_thread(fmt, args...)    LBTF_DEB_LL(LBTF_DEB_THREAD, " thread", fmt, ##args)
-#define lbtf_deb_sdio(fmt, args...)      LBTF_DEB_LL(LBTF_DEB_SDIO, " thread", fmt, ##args)
+#define lbtf_deb_sdio(fmt, args...)      LBTF_DEB_LL(LBTF_DEB_SDIO, " sdio", fmt, ##args)
 #define lbtf_deb_macops(fmt, args...)      LBTF_DEB_LL(LBTF_DEB_MACOPS, " thread", fmt, ##args)
+#define lbtf_deb_stats(fmt, args...)      LBTF_DEB_LL(LBTF_DEB_STATS, " statistics", fmt, ##args)
+#define lbtf_deb_int(fmt, args...)      LBTF_DEB_LL(LBTF_DEB_INT, " int", fmt, ##args)
 
 #ifdef DEBUG
 static inline void lbtf_deb_hex(unsigned int grp, const char *prompt, u8 *buf, int len)
diff -urN git//drivers/net/wireless/libertas_tf/if_sdio.c git-mod//drivers/net/wireless/libertas_tf/if_sdio.c
--- git//drivers/net/wireless/libertas_tf/if_sdio.c	1970-01-01 01:00:00.000000000 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/if_sdio.c	2012-01-31 07:15:13.700705536 +0100
@@ -0,0 +1,1429 @@
+/*
+ *  linux/drivers/net/wireless/libertas_tf/if_sdio.c
+ *
+ *  Copyright (C) 2010, cozybit Inc.
+ *
+ * Portions Copyright 2007-2008 Pierre Ossman
+ * Inspired by if_cs.c, Copyright 2007 Holger Schurig
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/firmware.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/sdio_ids.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/host.h>
+
+#define DRV_NAME "lbtf_sdio"
+
+#include "deb_defs.h"
+#include "libertas_tf.h"
+#include "if_sdio.h"
+
+static char *lbtf_helper_name = NULL;
+module_param_named(helper_name, lbtf_helper_name, charp, 0644);
+
+static char *lbtf_fw_name = NULL;
+module_param_named(fw_name, lbtf_fw_name, charp, 0644);
+
+static const struct sdio_device_id if_sdio_ids[] = {
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL,
+			SDIO_DEVICE_ID_MARVELL_LIBERTAS) },
+	{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL,
+			SDIO_DEVICE_ID_MARVELL_8688WLAN) },
+	{ /* end: all zeroes */				},
+};
+
+MODULE_DEVICE_TABLE(sdio, if_sdio_ids);
+
+struct if_sdio_model {
+	int model;
+	const char *helper;
+	const char *firmware;
+};
+
+extern unsigned int lbtf_reset_fw;
+
+static struct if_sdio_model if_sdio_models[] = {
+	{
+		/* 8686 */
+		.model = IF_SDIO_MODEL_8686,
+		.helper = "sd8686_helper.bin",
+		.firmware = "sd8686tf.bin",
+	},
+};
+MODULE_FIRMWARE("sd8686_helper.bin");
+MODULE_FIRMWARE("sd8686tf.bin");
+
+struct if_sdio_packet {
+	struct if_sdio_packet	*next;
+	u16			nb;
+	u8			buffer[0] __attribute__((aligned(4)));
+};
+
+struct if_sdio_card {
+	struct sdio_func	*func;
+	struct lbtf_private	*priv;
+
+	int			model;
+	unsigned long		ioport;
+	unsigned int		scratch_reg;
+
+	const char		*helper;
+	const char		*firmware;
+
+	u8			buffer[65536];
+
+	spinlock_t		lock;
+	struct if_sdio_packet	*packets;
+
+	struct workqueue_struct	*workqueue;
+	struct work_struct	packet_worker;
+
+	u8 hw_addr[ETH_ALEN];
+	u32 fwrelease;
+	u32 fwcapinfo;
+
+	u8			rx_unit;
+};
+
+static int _if_sdio_enable_interrupts(struct if_sdio_card *card)
+{
+	int ret;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, 0x0f, IF_SDIO_H_INT_MASK, &ret);
+	sdio_release_host(card->func);
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+	return (ret);
+}
+
+static int if_sdio_enable_interrupts(struct lbtf_private *priv)
+{
+	struct if_sdio_card *card = priv->card;
+	return _if_sdio_enable_interrupts(card);
+}
+
+static int _if_sdio_disable_interrupts(struct if_sdio_card *card)
+{
+	int ret;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	sdio_claim_host(card->func);
+	sdio_writeb(card->func, 0x00, IF_SDIO_H_INT_MASK, &ret);
+	sdio_release_host(card->func);
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+	return (ret);
+}
+
+static int if_sdio_disable_interrupts(struct lbtf_private *priv)
+{
+	struct if_sdio_card *card = priv->card;
+	return _if_sdio_disable_interrupts(card);
+}
+
+/*
+ *  For SD8385/SD8686, this function reads firmware status after
+ *  the image is downloaded, or reads RX packet length when
+ *  interrupt (with IF_SDIO_H_INT_UPLD bit set) is received.
+ */
+static u16 if_sdio_read_scratch(struct if_sdio_card *card, int *err)
+{
+	int ret;
+	u16 scratch;
+
+	lbtf_deb_enter(LBTF_DEB_SCRATCH);
+
+	scratch = sdio_readb(card->func, card->scratch_reg, &ret);
+	if (!ret)
+		scratch |= sdio_readb(card->func, card->scratch_reg + 1,
+					&ret) << 8;
+
+	if (err)
+		*err = ret;
+
+	if (ret)
+		return 0xffff;
+
+	lbtf_deb_leave_args(LBTF_DEB_SCRATCH, "scratch %x", scratch);
+	return scratch;
+}
+
+/********************************************************************/
+/* I/O                                                              */
+/********************************************************************/
+static u16 if_sdio_read_rx_len(struct if_sdio_card *card, int *err)
+{
+	int ret;
+	u16 rx_len;
+
+	switch (card->model) {
+	case IF_SDIO_MODEL_8385:
+	case IF_SDIO_MODEL_8686:
+		rx_len = if_sdio_read_scratch(card, &ret);
+		break;
+	case IF_SDIO_MODEL_8688:
+	default: /* for newer chipsets */
+		rx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);
+		if (!ret)
+			rx_len <<= card->rx_unit;
+		else
+			rx_len = 0xffff;	/* invalid length */
+
+		break;
+	}
+
+	if (err)
+		*err = ret;
+
+	return rx_len;
+}
+
+static int if_sdio_handle_cmd(struct if_sdio_card *card,
+		u8 *buffer, unsigned size)
+{
+	struct lbtf_private *priv = card->priv;
+	int ret;
+	unsigned long flags;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	if (size > LBS_CMD_BUFFER_SIZE) {
+		lbtf_deb_sdio("response packet too large (%u bytes)\n",
+			size);
+		ret = -E2BIG;
+		goto out;
+	}
+
+	spin_lock_irqsave(&priv->driver_lock, flags);
+
+	memcpy(priv->cmd_resp_buff, buffer, size);
+	lbtf_cmd_response_rx(priv);
+
+	spin_unlock_irqrestore(&card->priv->driver_lock, flags);
+
+	ret = 0;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+	return ret;
+}
+
+static int if_sdio_handle_data(struct if_sdio_card *card,
+		u8 *buffer, unsigned size)
+{
+	int ret;
+	struct sk_buff *skb;
+	char *data;
+
+	lbtf_deb_enter(LBTF_DEB_INT);
+
+	if (size > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {
+		lbtf_deb_sdio("response packet too large (%u bytes)\n",
+			size);
+		ret = -E2BIG;
+		goto out;
+	}
+
+	skb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + NET_IP_ALIGN);
+	if (!skb) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	skb_reserve(skb, NET_IP_ALIGN);
+
+	data = skb_put(skb, size);
+
+	memcpy(data, buffer, size);
+
+	lbtf_rx(card->priv, skb);
+
+	ret = 0;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_INT, "ret %d", ret);
+
+	return ret;
+}
+
+static int if_sdio_handle_event(struct if_sdio_card *card,
+		u8 *buffer, unsigned size)
+{
+	int ret = 0;
+	u32 event;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	if (card->model == IF_SDIO_MODEL_8385) {
+		event = sdio_readb(card->func, IF_SDIO_EVENT, &ret);
+		if (ret)
+			goto out;
+
+		/* right shift 3 bits to get the event id */
+		event >>= 3;
+	} else {
+		if (size < 4) {
+			lbtf_deb_sdio("event packet too small (%u bytes)\n",
+				size);
+			ret = -EINVAL;
+			goto out;
+		}
+		event = buffer[3] << 24;
+		event |= buffer[2] << 16;
+		event |= buffer[1] << 8;
+		event |= buffer[0] << 0;
+	}
+
+	lbtf_deb_stats("**EVENT** 0x%X\n", event);
+
+	if (event & 0xffff0000) {
+			u16 tmp;
+			u8 retrycnt;
+			u8 failure;
+
+			tmp = event >> 16;
+			retrycnt = tmp & 0x00ff;
+			failure = (tmp & 0xff00) >> 8;
+			lbtf_deb_stats("Got feedback event. retry: %d, failure: %d", retrycnt, failure);
+			lbtf_send_tx_feedback(card->priv, retrycnt, failure);
+		} else if (event == LBTF_EVENT_BCN_SENT) {
+			lbtf_bcn_sent(card->priv);
+		} else {
+			lbtf_deb_stats("UNKNOWN HOST EVENT: 0x%x", event);
+		}
+
+	ret = 0;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+static int if_sdio_wait_status(struct if_sdio_card *card, const u8 condition)
+{
+	u8 status;
+	unsigned long timeout;
+	int ret = 0;
+
+	timeout = jiffies + HZ;
+	while (1) {
+		status = sdio_readb(card->func, IF_SDIO_STATUS, &ret);
+		if (ret)
+			return ret;
+		if ((status & condition) == condition)
+			break;
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		mdelay(1);
+	}
+
+	return ret;
+}
+
+static int if_sdio_card_to_host(struct if_sdio_card *card)
+{
+	int ret;
+	u16 size, type, chunk;
+
+	lbtf_deb_enter(LBTF_DEB_INT);
+
+
+	size = if_sdio_read_rx_len(card, &ret);
+	if (ret)
+		goto out;
+
+	if (size < 4) {
+		lbtf_deb_sdio("invalid packet size (%hu bytes) from firmware\n",
+			size);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	ret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);
+	if (ret)
+		goto out;
+
+	/*
+	 * The transfer must be in one transaction or the firmware
+	 * goes suicidal. There's no way to guarantee that for all
+	 * controllers, but we can at least try.
+	 */
+	chunk = sdio_align_size(card->func, size);
+
+	ret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);
+	if (ret)
+		goto out;
+
+	chunk = card->buffer[0] | (card->buffer[1] << 8);
+	type = card->buffer[2] | (card->buffer[3] << 8);
+
+	lbtf_deb_int("packet of type %hu and size %hu bytes\n",
+		type, chunk);
+
+	if (chunk > size) {
+		lbtf_deb_sdio("packet fragment (%hu > %hu)\n",
+			chunk, size);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (chunk < size) {
+		lbtf_deb_sdio("packet fragment (%hu < %hu)\n",
+			chunk, size);
+	}
+
+	switch (type) {
+	case MVMS_CMD:
+		ret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);
+		if (ret)
+			goto out;
+		break;
+	case MVMS_DAT:
+		ret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);
+		if (ret)
+			goto out;
+		break;
+	case MVMS_EVENT:
+		ret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);
+		if (ret)
+			goto out;
+		break;
+	default:
+		lbtf_deb_sdio("invalid type (%hu) from firmware\n",
+				type);
+		ret = -EINVAL;
+		goto out;
+	}
+
+out:
+	if (ret)
+		pr_err("problem fetching packet from firmware\n");
+
+	lbtf_deb_leave_args(LBTF_DEB_INT, "ret %d", ret);
+
+	return ret;
+}
+
+static void if_sdio_host_to_card_worker(struct work_struct *work)
+{
+	struct if_sdio_card *card;
+	struct if_sdio_packet *packet;
+	int ret;
+	unsigned long flags;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	card = container_of(work, struct if_sdio_card, packet_worker);
+
+	while (1) {
+		spin_lock_irqsave(&card->lock, flags);
+		packet = card->packets;
+		if (packet)
+			card->packets = packet->next;
+		spin_unlock_irqrestore(&card->lock, flags);
+
+		if (!packet)
+			break;
+
+		// Check for removed device
+		if (card->priv) {
+			if (card->priv->surpriseremoved) {
+				lbtf_deb_sdio("Device removed\n");
+				kfree(packet);
+				break;
+			}
+		} else {
+			lbtf_deb_sdio("host->card called during init, assuming device exists");
+		}
+
+		sdio_claim_host(card->func);
+
+		ret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);
+		if (ret == 0) {
+			ret = sdio_writesb(card->func, card->ioport,
+					   packet->buffer, packet->nb);
+		}
+
+		if (ret)
+			pr_err("error %d sending packet to firmware\n", ret);
+
+		sdio_release_host(card->func);
+
+		kfree(packet);
+	}
+
+	lbtf_deb_leave(LBTF_DEB_SDIO);
+}
+
+/********************************************************************/
+/* Firmware                                                         */
+/********************************************************************/
+
+#define FW_DL_READY_STATUS (IF_SDIO_IO_RDY | IF_SDIO_DL_RDY)
+
+static int if_sdio_prog_helper(struct if_sdio_card *card)
+{
+	int ret;
+	const struct firmware *fw;
+	unsigned long timeout;
+	u8 *chunk_buffer;
+	u32 chunk_size;
+	const u8 *firmware;
+	size_t size;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	ret = request_firmware(&fw, card->helper, &card->func->dev);
+
+	if (ret) {
+		pr_err("failed to load helper firmware\n");
+		goto out;
+	}
+
+	chunk_buffer = kzalloc(64, GFP_KERNEL);
+	if (!chunk_buffer) {
+		ret = -ENOMEM;
+		goto release_fw;
+	}
+
+	sdio_claim_host(card->func);
+
+	ret = sdio_set_block_size(card->func, 32);
+	if (ret)
+		goto release;
+
+	firmware = fw->data;
+	size = fw->size;
+
+	lbtf_deb_sdio("Helper size: %d", size);
+
+	while (size) {
+		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
+		if (ret)
+			goto release;
+
+		/* On some platforms (like Davinci) the chip needs more time
+		 * between helper blocks.
+		 */
+		mdelay(2);
+
+		chunk_size = min(size, 60U);
+
+		*((__le32*)chunk_buffer) = cpu_to_le32(chunk_size);
+		memcpy(chunk_buffer + 4, firmware, chunk_size);
+
+		// lbtf_deb_sdio("sending %d bytes chunk\n", chunk_size);
+
+		ret = sdio_writesb(card->func, card->ioport,
+				chunk_buffer, 64);
+		if (ret)
+			goto release;
+
+		firmware += chunk_size;
+		size -= chunk_size;
+	}
+
+	/* an empty block marks the end of the transfer */
+	memset(chunk_buffer, 0, 4);
+	ret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);
+	if (ret)
+		goto release;
+
+	lbtf_deb_sdio("waiting for helper to boot...\n");
+
+	/* wait for the helper to boot by looking at the size register */
+	timeout = jiffies + HZ;
+	while (1) {
+		u16 req_size;
+
+		req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
+		if (ret)
+			goto release;
+
+		req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
+		if (ret)
+			goto release;
+
+		if (req_size != 0)
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			ret = -ETIMEDOUT;
+			goto release;
+		}
+
+		msleep(10);
+	}
+
+	ret = 0;
+
+release:
+	sdio_release_host(card->func);
+	kfree(chunk_buffer);
+release_fw:
+	release_firmware(fw);
+
+out:
+	if (ret)
+		pr_err("failed to load helper firmware\n");
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+static int if_sdio_prog_real(struct if_sdio_card *card)
+{
+	int ret;
+	const struct firmware *fw;
+	unsigned long timeout;
+	u8 *chunk_buffer;
+	u32 chunk_size;
+	const u8 *firmware;
+	size_t size, req_size;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	ret = request_firmware(&fw, card->firmware, &card->func->dev);
+	if (ret) {
+		pr_err("can't load firmware\n");
+		goto out;
+	}
+
+	chunk_buffer = kzalloc(512, GFP_KERNEL);
+	if (!chunk_buffer) {
+		ret = -ENOMEM;
+		goto release_fw;
+	}
+
+	sdio_claim_host(card->func);
+
+	ret = sdio_set_block_size(card->func, 32);
+	if (ret)
+		goto release;
+
+	firmware = fw->data;
+	size = fw->size;
+
+	lbtf_deb_sdio("Firmware size: %d", size);
+
+	while (size) {
+		ret = if_sdio_wait_status(card, FW_DL_READY_STATUS);
+		if (ret)
+			goto release;
+
+		req_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);
+		if (ret)
+			goto release;
+
+		req_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;
+		if (ret)
+			goto release;
+
+		if (req_size == 0) {
+			lbtf_deb_sdio("firmware helper gave up early\n");
+			ret = -EIO;
+			goto release;
+		}
+
+		if (req_size & 0x01) {
+			lbtf_deb_sdio("firmware helper signalled error\n");
+			ret = -EIO;
+			goto release;
+		}
+
+		if (req_size > size)
+			req_size = size;
+
+		while (req_size) {
+			chunk_size = min(req_size, (size_t)512);
+
+			memcpy(chunk_buffer, firmware, chunk_size);
+			ret = sdio_writesb(card->func, card->ioport,
+				chunk_buffer, roundup(chunk_size, 32));
+			if (ret)
+				goto release;
+
+			firmware += chunk_size;
+			size -= chunk_size;
+			req_size -= chunk_size;
+		}
+	}
+
+	ret = 0;
+
+	lbtf_deb_sdio("waiting for firmware to boot...\n");
+
+	/* wait for the firmware to boot */
+	timeout = jiffies + HZ;
+	while (1) {
+		u16 scratch;
+
+		scratch = if_sdio_read_scratch(card, &ret);
+		if (ret)
+			goto release;
+
+		if (scratch == IF_SDIO_FIRMWARE_OK)
+			break;
+
+		if (time_after(jiffies, timeout)) {
+			ret = -ETIMEDOUT;
+			goto release;
+		}
+
+		msleep(10);
+	}
+
+	ret = 0;
+
+release:
+	sdio_release_host(card->func);
+	kfree(chunk_buffer);
+release_fw:
+	release_firmware(fw);
+
+out:
+	if (ret)
+		pr_err("failed to load firmware\n");
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+static void if_sdio_reset_device(struct if_sdio_card *card);
+
+static int if_sdio_prog_firmware(struct if_sdio_card *card)
+{
+	int ret;
+	u16 scratch;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	/*
+	 * Disable interrupts
+	 */
+	ret = _if_sdio_disable_interrupts(card);
+	if (ret)
+		pr_warning("unable to disable interrupts: %d", ret);
+
+	sdio_claim_host(card->func);
+	scratch = if_sdio_read_scratch(card, &ret);
+	sdio_release_host(card->func);
+
+	lbtf_deb_sdio("firmware status = %#x\n", scratch);
+	lbtf_deb_sdio("scratch ret = %d\n", ret);
+
+	if (ret)
+		goto out;
+
+	if (scratch == IF_SDIO_FIRMWARE_OK) {
+		lbtf_deb_sdio("firmware already loaded\n");
+		goto success;
+	} else if ((card->model == IF_SDIO_MODEL_8686) && ((scratch & 0x7fff) != 0)) {
+		lbtf_deb_sdio("firmware may be running\n");
+		if( lbtf_reset_fw == 0 ) {
+			goto success;
+		} else {
+			lbtf_deb_sdio("attempting to reset and reload firmware\n");
+
+			if_sdio_reset_device(card);
+			lbtf_reset_fw=0;
+
+			ret = if_sdio_prog_firmware(card);
+			goto out;
+		}
+	}
+
+	ret = if_sdio_prog_helper(card);
+	if (ret)
+		goto out;
+
+	lbtf_deb_sdio("Helper firmware loaded\n");
+
+	ret = if_sdio_prog_real(card);
+	if (ret)
+		goto out;
+
+	lbtf_deb_sdio("Firmware loaded\n");
+
+success:
+	sdio_claim_host(card->func);
+	sdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);
+	sdio_release_host(card->func);
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+/*******************************************************************/
+/* Libertas callbacks                                              */
+/*******************************************************************/
+
+static int _if_sdio_host_to_card(struct if_sdio_card *card,
+		u8 type, u8 *buf, u16 nb)
+{
+	int ret;
+	struct if_sdio_packet *packet, *cur;
+	u16 size;
+	unsigned long flags;
+
+	lbtf_deb_enter_args(LBTF_DEB_SDIO, "type %d, bytes %d", type, nb);
+
+	if (nb > (65536 - sizeof(struct if_sdio_packet) - 4)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * The transfer must be in one transaction or the firmware
+	 * goes suicidal. There's no way to guarantee that for all
+	 * controllers, but we can at least try.
+	 */
+	size = sdio_align_size(card->func, nb + 4);
+
+	packet = kzalloc(sizeof(struct if_sdio_packet) + size,
+			GFP_ATOMIC);
+	if (!packet) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	packet->next = NULL;
+	packet->nb = size;
+
+	/*
+	 * SDIO specific header.
+	 */
+	packet->buffer[0] = (nb + 4) & 0xff;
+	packet->buffer[1] = ((nb + 4) >> 8) & 0xff;
+	packet->buffer[2] = type;
+	packet->buffer[3] = 0;
+
+	memcpy(packet->buffer + 4, buf, nb);
+
+	spin_lock_irqsave(&card->lock, flags);
+
+	if (!card->packets)
+		card->packets = packet;
+	else {
+		cur = card->packets;
+		while (cur->next)
+			cur = cur->next;
+		cur->next = packet;
+	}
+
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	queue_work(card->workqueue, &card->packet_worker);
+
+	ret = 0;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+static int if_sdio_host_to_card(struct lbtf_private *priv,
+		u8 type, u8 *buf, u16 nb)
+{
+	struct if_sdio_card *card;
+	unsigned long flags;
+
+	card = priv->card;
+
+	spin_lock_irqsave(&card->lock, flags);
+	/* TODO: the dndl_sent has to do with sleep stuff.
+	 * Commented out till we add that.
+	 */
+	switch (type) {
+	case MVMS_CMD:
+		/* priv->dnld_sent = DNLD_CMD_SENT;
+		break; */
+	case MVMS_DAT:
+		/*priv->dnld_sent = DNLD_DATA_SENT;*/
+		break;
+	default:
+		lbtf_deb_sdio("unknown packet type %d\n", (int)type);
+	}
+	spin_unlock_irqrestore(&card->lock, flags);
+
+	return _if_sdio_host_to_card(card, type, buf, nb);
+}
+
+static int if_sdio_enter_deep_sleep(struct lbtf_private *priv)
+{
+	int ret = -1;
+	return ret;
+}
+
+static int if_sdio_exit_deep_sleep(struct lbtf_private *priv)
+{
+	int ret = -1;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+	return ret;
+}
+
+static int if_sdio_reset_deep_sleep_wakeup(struct lbtf_private *priv)
+{
+	int ret = -1;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+	return ret;
+}
+
+static void if_sdio_reset_device(struct if_sdio_card *card)
+{
+	struct cmd_ds_802_11_reset cmd;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.hdr.command = cpu_to_le16(CMD_802_11_RESET);
+	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
+	cmd.action = cpu_to_le16(CMD_ACT_HALT);
+
+	_if_sdio_host_to_card(card, MVMS_CMD, (u8 *) &cmd, sizeof(cmd));
+
+	msleep(1000);
+
+	lbtf_deb_leave(LBTF_DEB_SDIO);
+
+	return;
+}
+EXPORT_SYMBOL_GPL(if_sdio_reset_device);
+
+/**
+ *  lbtf_update_hw_spec: Updates the hardware details.
+ *
+ *  @priv    	A pointer to struct lbtf_private structure
+ *
+ *  Returns: 0 on success, error on failure
+ */
+int if_sdio_update_hw_spec(struct if_sdio_card *card)
+{
+	struct cmd_ds_get_hw_spec cmd;
+	int ret = -1;
+	unsigned long timeout;
+	u16 size, type, chunk;
+	int wait_cmd_done = 0;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	/* Send hw spec command */
+	memset(&cmd, 0, sizeof(cmd));
+	cmd.hdr.size = cpu_to_le16(sizeof(cmd));
+	cmd.hdr.command = cpu_to_le16(CMD_GET_HW_SPEC);
+	memcpy(cmd.permanentaddr, card->hw_addr, ETH_ALEN);
+	ret = _if_sdio_host_to_card(card, MVMS_CMD, (u8 *) &cmd, sizeof(cmd));
+	if (ret) {
+		goto out;
+	}
+
+	flush_workqueue(card->workqueue);
+
+	/* Wait for and retrieve response */
+	timeout = jiffies + HZ;
+	while (wait_cmd_done < 1) {
+		/* Wait for response to cmd */
+		sdio_claim_host(card->func);
+		ret = if_sdio_wait_status(card, IF_SDIO_UL_RDY);
+		sdio_release_host(card->func);
+		if (ret) {
+			/* time-out */
+			lbtf_deb_sdio("error waiting on IO ready");
+			goto out;
+		}
+
+		/* get the rx size */
+		sdio_claim_host(card->func);
+		size = if_sdio_read_rx_len(card, &ret);
+		sdio_release_host(card->func);
+		if (ret)
+			goto out;
+
+		if (size == 0) {
+		} else if (size < 4) {
+			lbtf_deb_sdio("invalid packet size (%d bytes) from firmware\n",
+				(int)size);
+			ret = -EINVAL;
+			goto out;
+		} else /* size > 4 */ {
+			/*
+			 * Get command response.
+			 *
+			 * The transfer must be in one transaction or the firmware
+			 * goes suicidal. There's no way to guarantee that for all
+			 * controllers, but we can at least try.
+			 */
+			sdio_claim_host(card->func);
+			chunk = sdio_align_size(card->func, size);
+
+			ret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);
+			sdio_release_host(card->func);
+			if (ret)
+				goto out;
+
+			chunk = card->buffer[0] | (card->buffer[1] << 8);
+			type = card->buffer[2] | (card->buffer[3] << 8);
+
+			lbtf_deb_sdio("packet of type %hu and size %hu bytes\n",
+				type, chunk);
+
+			lbtf_deb_hex(LBTF_DEB_SDIO, "SDIO Rx: ", card->buffer,
+						 min_t(unsigned int, size, 100));
+
+			if (chunk > size) {
+				lbtf_deb_sdio("packet fragment (%hu > %hu)\n",
+					chunk, size);
+				ret = -EINVAL;
+				goto out;
+			}
+
+			if (chunk < size) {
+				lbtf_deb_sdio("packet fragment (%hu < %hu)\n",
+					chunk, size);
+			}
+
+			switch (type) {
+			case MVMS_DAT:
+				lbtf_deb_sdio("Got MVMS_DAT");
+				continue;
+			case MVMS_CMD:
+				lbtf_deb_sdio("Got MVMS_CMD");
+				memcpy(&cmd, card->buffer +4, sizeof(cmd));
+				wait_cmd_done = 1;
+				break;
+			case MVMS_EVENT:
+				lbtf_deb_sdio("Got MVMS_EVENT");
+				continue;
+			default:
+				lbtf_deb_sdio("invalid type (%hu) from firmware\n",
+						type);
+				ret = -EINVAL;
+				goto out;
+			}
+		} /* size > 4 */
+
+		if (!wait_cmd_done) {
+			if (time_after(jiffies, timeout)) {
+				ret = -ETIMEDOUT;
+				pr_warning("Update hw spec cmd timed out\n");
+				ret = -1;
+				goto out;
+			}
+
+			msleep(10);
+		}
+	}
+
+	lbtf_deb_sdio("Got hw spec command response");
+
+	/* Process cmd return */
+	card->fwcapinfo = le32_to_cpu(cmd.fwcapinfo);
+
+	/* The firmware release is in an interesting format: the patch
+	 * level is in the most significant nibble ... so fix that: */
+	card->fwrelease = le32_to_cpu(cmd.fwrelease);
+	card->fwrelease = (card->fwrelease << 8) |
+		(card->fwrelease >> 24 & 0xff);
+
+	printk(KERN_INFO "libertas_tf_sdio: %pM, fw %u.%u.%up%u, cap 0x%08x\n",
+		cmd.permanentaddr,
+		card->fwrelease >> 24 & 0xff,
+		card->fwrelease >> 16 & 0xff,
+		card->fwrelease >>  8 & 0xff,
+		card->fwrelease       & 0xff,
+		card->fwcapinfo);
+	lbtf_deb_sdio("GET_HW_SPEC: hardware interface 0x%x, hardware spec 0x%04x\n",
+		    cmd.hwifversion, cmd.version);
+
+	memmove(card->hw_addr, cmd.permanentaddr, ETH_ALEN);
+
+out:
+	lbtf_deb_leave(LBTF_DEB_SDIO);
+	return ret;
+}
+
+
+/*******************************************************************/
+/* SDIO callbacks                                                  */
+/*******************************************************************/
+
+static void if_sdio_interrupt(struct sdio_func *func)
+{
+	int ret;
+	struct if_sdio_card *card;
+	u8 cause;
+
+	lbtf_deb_enter(LBTF_DEB_INT);
+
+	card = sdio_get_drvdata(func);
+
+	cause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);
+	lbtf_deb_int("interrupt: 0x%hhX\n", cause);
+	lbtf_deb_int("interrupt ret: 0x%X\n", ret);
+	if (ret)
+		goto out;
+
+	sdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);
+	if (ret)
+		goto out;
+
+	/*
+	 * Ignore the define name, this really means the card has
+	 * successfully received the command or packet.
+	 */
+	if (cause & IF_SDIO_H_INT_DNLD)
+		if (card->priv)
+			lbtf_host_to_card_done(card->priv);
+
+	if (cause & IF_SDIO_H_INT_UPLD) {
+		ret = if_sdio_card_to_host(card);
+		if (ret)
+			goto out;
+	}
+
+	ret = 0;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_INT, "ret %d", ret);
+}
+
+static int if_sdio_probe(struct sdio_func *func,
+		const struct sdio_device_id *id)
+{
+	struct if_sdio_card *card;
+	struct lbtf_private *priv;
+	int ret, i;
+	unsigned int model;
+	struct if_sdio_packet *packet;
+	struct mmc_host *host = func->card->host;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	for (i = 0;i < func->card->num_info;i++) {
+		if (sscanf(func->card->info[i],
+				"802.11 SDIO ID: %x", &model) == 1)
+			break;
+		if (sscanf(func->card->info[i],
+				"ID: %x", &model) == 1)
+			break;
+		if (!strcmp(func->card->info[i], "IBIS Wireless SDIO Card")) {
+			model = IF_SDIO_MODEL_8385;
+			break;
+		}
+	}
+
+	if (i == func->card->num_info) {
+		pr_err("unable to identify card model\n");
+		return -ENODEV;
+	}
+
+	lbtf_deb_sdio("Found model: 0x%x", model);
+
+	card = kzalloc(sizeof(struct if_sdio_card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	card->func = func;
+	card->model = model;
+
+	switch (card->model) {
+	case IF_SDIO_MODEL_8385:
+		card->scratch_reg = IF_SDIO_SCRATCH_OLD;
+		break;
+	case IF_SDIO_MODEL_8686:
+		lbtf_deb_sdio("Found Marvell 8686");
+		card->scratch_reg = IF_SDIO_SCRATCH;
+		break;
+	case IF_SDIO_MODEL_8688:
+	default: /* for newer chipsets */
+		card->scratch_reg = IF_SDIO_FW_STATUS;
+		break;
+	}
+
+	spin_lock_init(&card->lock);
+	card->workqueue = create_workqueue("libertas_tf_sdio");
+	INIT_WORK(&card->packet_worker, if_sdio_host_to_card_worker);
+
+	for (i = 0;i < ARRAY_SIZE(if_sdio_models);i++) {
+		if (card->model == if_sdio_models[i].model)
+			break;
+	}
+
+	if (i == ARRAY_SIZE(if_sdio_models)) {
+		pr_err("unknown card model 0x%x\n", card->model);
+		ret = -ENODEV;
+		goto free;
+	}
+
+	card->helper = if_sdio_models[i].helper;
+	card->firmware = if_sdio_models[i].firmware;
+
+	if (lbtf_helper_name) {
+		lbtf_deb_sdio("overriding helper firmware: %s\n",
+			lbtf_helper_name);
+		card->helper = lbtf_helper_name;
+	}
+
+	if (lbtf_fw_name) {
+		lbtf_deb_sdio("overriding firmware: %s\n", lbtf_fw_name);
+		card->firmware = lbtf_fw_name;
+	}
+
+	sdio_claim_host(func);
+
+	ret = sdio_enable_func(func);
+	if (ret)
+		goto release;
+
+	ret = sdio_claim_irq(func, if_sdio_interrupt);
+	if (ret)
+		goto disable;
+
+	/* For 1-bit transfers to the 8686 model, we need to enable the
+	 * interrupt flag in the CCCR register. Set the MMC_QUIRK_LENIENT_FN0
+	 * bit to allow access to non-vendor registers. */
+	if ((card->model == IF_SDIO_MODEL_8686) &&
+	    (host->caps & MMC_CAP_SDIO_IRQ) &&
+	    (host->ios.bus_width == MMC_BUS_WIDTH_1)) {
+		u8 reg;
+
+		func->card->quirks |= MMC_QUIRK_LENIENT_FN0;
+		reg = sdio_f0_readb(func, SDIO_CCCR_IF, &ret);
+		if (ret)
+			goto release_int;
+
+		reg |= SDIO_BUS_ECSI;
+		sdio_f0_writeb(func, reg, SDIO_CCCR_IF, &ret);
+		if (ret)
+			goto release_int;
+	}
+
+	card->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);
+	if (ret)
+		goto release_int;
+
+	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;
+	if (ret)
+		goto release_int;
+
+	card->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;
+	if (ret)
+		goto release_int;
+
+	sdio_release_host(func);
+	sdio_set_drvdata(func, card);
+
+	lbtf_deb_sdio("class = 0x%X, vendor = 0x%X, "
+			"device = 0x%X, model = 0x%X, ioport = 0x%luX\n",
+			func->class, func->vendor, func->device,
+			model, card->ioport);
+
+	/* Upload firmware */
+	lbtf_deb_sdio("Going to upload fw...");
+	if (if_sdio_prog_firmware(card))
+		goto reclaim;
+
+	/*
+	 * We need to get the hw spec here because we must have the
+	 * MAC address before we call lbtf_add_card
+	 *
+	 * Read priv address from HW
+	 */
+	memset(card->hw_addr, 0xff, ETH_ALEN);
+	ret = if_sdio_update_hw_spec(card);
+	if (ret) {
+		ret = -1;
+		pr_err("Error fetching MAC address from hardware.");
+		goto reclaim;
+	}
+
+	priv = lbtf_add_card(card, &func->dev, card->hw_addr);
+	if (!priv) {
+		ret = -ENOMEM;
+		goto reclaim;
+	}
+
+	card->priv = priv;
+	priv->card = card;
+
+	priv->hw_host_to_card = if_sdio_host_to_card;
+	priv->enter_deep_sleep = if_sdio_enter_deep_sleep;
+	priv->exit_deep_sleep = if_sdio_exit_deep_sleep;
+	priv->reset_deep_sleep_wakeup = if_sdio_reset_deep_sleep_wakeup;
+	priv->enable_interrupts = if_sdio_enable_interrupts;
+	priv->disable_interrupts = if_sdio_disable_interrupts;
+
+	/* SD8385 & SD8686 do not have rx_unit.	*/
+	card->rx_unit = 0;
+
+	/*
+	 * Enable interrupts now that everything is set up
+	 */
+	ret = _if_sdio_enable_interrupts(card);
+	if (ret) {
+		pr_err("Error enabling interrupts: %d", ret);
+		goto err_activate_card;
+	}
+
+	priv->fw_ready = 1;
+
+out:
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+
+err_activate_card:
+	lbtf_deb_sdio("prob error jump: err_activate_card");
+	flush_workqueue(card->workqueue);
+	lbtf_remove_card(priv);
+reclaim:
+	lbtf_deb_sdio("prob error jump: reclaim");
+	sdio_claim_host(func);
+release_int:
+	lbtf_deb_sdio("prob error jump: release_int");
+	sdio_release_irq(func);
+disable:
+	lbtf_deb_sdio("prob error jump: disable");
+	sdio_disable_func(func);
+release:
+	lbtf_deb_sdio("prob error jump: release");
+	sdio_release_host(func);
+free:
+	lbtf_deb_sdio("prob error jump: free");
+	destroy_workqueue(card->workqueue);
+	while (card->packets) {
+		packet = card->packets;
+		card->packets = card->packets->next;
+		kfree(packet);
+	}
+
+	kfree(card);
+
+	goto out;
+}
+
+static void if_sdio_remove(struct sdio_func *func)
+{
+	struct if_sdio_card *card;
+	struct if_sdio_packet *packet;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	card = sdio_get_drvdata(func);
+
+	card->priv->surpriseremoved = 1;
+
+	lbtf_deb_sdio("call remove card\n");
+	lbtf_remove_card(card->priv);
+
+	flush_workqueue(card->workqueue);
+	destroy_workqueue(card->workqueue);
+
+	sdio_claim_host(func);
+	sdio_release_irq(func);
+	sdio_disable_func(func);
+	sdio_set_drvdata(func, NULL);
+	sdio_release_host(func);
+
+	while (card->packets) {
+		packet = card->packets;
+		card->packets = card->packets->next;
+		kfree(packet);
+	}
+
+	kfree(card);
+
+	lbtf_deb_leave(LBTF_DEB_SDIO);
+}
+
+static int if_sdio_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int if_sdio_resume(struct device *dev)
+{
+	return 0;
+}
+
+static struct dev_pm_ops if_sdio_pm_ops = {
+	.suspend	= if_sdio_suspend,
+	.resume		= if_sdio_resume,
+};
+
+static struct sdio_driver if_sdio_driver = {
+	.name		= "libertas_tf_sdio",
+	.id_table	= if_sdio_ids,
+	.probe		= if_sdio_probe,
+	.remove		= if_sdio_remove,
+	.drv = {
+		.pm = &if_sdio_pm_ops,
+	},
+};
+
+/*******************************************************************/
+/* Module functions                                                */
+/*******************************************************************/
+
+static int __init if_sdio_init_module(void)
+{
+	int ret = 0;
+
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+	printk(KERN_INFO "libertas_tf_sdio: Libertas Thinfirmware SDIO driver\n");
+	printk(KERN_INFO "libertas_tf_sdio: Copyright cozybit Inc.\n");
+	printk(KERN_INFO "libertas_tf_sdio: buildstamp: 6\n");
+
+	ret = sdio_register_driver(&if_sdio_driver);
+
+	lbtf_deb_leave_args(LBTF_DEB_SDIO, "ret %d", ret);
+
+	return ret;
+}
+
+static void __exit if_sdio_exit_module(void)
+{
+	lbtf_deb_enter(LBTF_DEB_SDIO);
+
+
+	sdio_unregister_driver(&if_sdio_driver);
+
+	lbtf_deb_leave(LBTF_DEB_SDIO);
+}
+
+module_init(if_sdio_init_module);
+module_exit(if_sdio_exit_module);
+
+MODULE_DESCRIPTION("Libertas_tf SDIO WLAN Driver");
+MODULE_AUTHOR("Steve deRosier");
+MODULE_LICENSE("GPL");
diff -urN git//drivers/net/wireless/libertas_tf/if_sdio.h git-mod//drivers/net/wireless/libertas_tf/if_sdio.h
--- git//drivers/net/wireless/libertas_tf/if_sdio.h	1970-01-01 01:00:00.000000000 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/if_sdio.h	2012-01-31 07:15:13.700705536 +0100
@@ -0,0 +1,56 @@
+/*
+ *  linux/drivers/net/wireless/libertas/if_sdio.h
+ *
+ *  Copyright 2007 Pierre Ossman
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ */
+
+#ifndef _LBS_IF_SDIO_H
+#define _LBS_IF_SDIO_H
+
+#define IF_SDIO_MODEL_8385	0x04
+#define IF_SDIO_MODEL_8686	0x0b
+#define IF_SDIO_MODEL_8688	0x10
+
+#define IF_SDIO_IOPORT		0x00
+
+#define IF_SDIO_H_INT_MASK	0x04
+#define   IF_SDIO_H_INT_OFLOW	0x08
+#define   IF_SDIO_H_INT_UFLOW	0x04
+#define   IF_SDIO_H_INT_DNLD	0x02
+#define   IF_SDIO_H_INT_UPLD	0x01
+
+#define IF_SDIO_H_INT_STATUS	0x05
+#define IF_SDIO_H_INT_RSR	0x06
+#define IF_SDIO_H_INT_STATUS2	0x07
+
+#define IF_SDIO_RD_BASE		0x10
+
+#define IF_SDIO_STATUS		0x20
+#define   IF_SDIO_IO_RDY	0x08
+#define   IF_SDIO_CIS_RDY	0x04
+#define   IF_SDIO_UL_RDY	0x02
+#define   IF_SDIO_DL_RDY	0x01
+
+#define IF_SDIO_C_INT_MASK	0x24
+#define IF_SDIO_C_INT_STATUS	0x28
+#define IF_SDIO_C_INT_RSR	0x2C
+
+#define IF_SDIO_SCRATCH		0x34
+#define IF_SDIO_SCRATCH_OLD	0x80fe
+#define IF_SDIO_FW_STATUS	0x40
+#define   IF_SDIO_FIRMWARE_OK	0xfedc
+
+#define IF_SDIO_RX_LEN		0x42
+#define IF_SDIO_RX_UNIT		0x43
+
+#define IF_SDIO_EVENT           0x80fc
+
+#define IF_SDIO_BLOCK_SIZE	256
+#define CONFIGURATION_REG               0x03
+#define HOST_POWER_UP                   (0x1U << 1)
+#endif
diff -urN git//drivers/net/wireless/libertas_tf/if_usb.c git-mod//drivers/net/wireless/libertas_tf/if_usb.c
--- git//drivers/net/wireless/libertas_tf/if_usb.c	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/if_usb.c	2012-01-31 07:15:13.700705536 +0100
@@ -43,6 +43,8 @@
 static void if_usb_receive(struct urb *urb);
 static void if_usb_receive_fwload(struct urb *urb);
 static int if_usb_prog_firmware(struct if_usb_card *cardp);
+static int _if_usb_host_to_card(struct if_usb_card *cardp, uint8_t type,
+			       uint8_t *payload, uint16_t nb);
 static int if_usb_host_to_card(struct lbtf_private *priv, uint8_t type,
 			       uint8_t *payload, uint16_t nb);
 static int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload,
@@ -50,11 +52,13 @@
 static void if_usb_free(struct if_usb_card *cardp);
 static int if_usb_submit_rx_urb(struct if_usb_card *cardp);
 static int if_usb_reset_device(struct if_usb_card *cardp);
+static int __if_usb_submit_rx_urb(struct if_usb_card *cardp,
+				  void (*callbackfn)(struct urb *urb));
 
 /**
  *  if_usb_wrike_bulk_callback -  call back to handle URB status
  *
- *  @param urb 		pointer to urb structure
+ *  @param urb		pointer to urb structure
  */
 static void if_usb_write_bulk_callback(struct urb *urb)
 {
@@ -97,22 +101,143 @@
 	lbtf_deb_leave(LBTF_DEB_USB);
 }
 
-static void if_usb_setup_firmware(struct lbtf_private *priv)
+/**
+ *  if_usb_receive_hw_spec - read data received from the device.
+ *
+ *  @urb		pointer to struct urb
+ */
+static void if_usb_receive_cmd_response(struct urb *urb)
+{
+	struct if_usb_card *cardp = urb->context;
+	struct sk_buff *skb = cardp->rx_skb;
+	int recvlength = urb->actual_length;
+	uint8_t *recvbuff = NULL;
+	uint32_t recvtype = 0;
+	__le32 *pkt = (__le32 *)(skb->data);
+	struct cmd_ds_get_hw_spec *cmd;
+
+	lbtf_deb_enter(LBTF_DEB_USB);
+
+	if (recvlength>0) {
+		if (urb->status) {
+			lbtf_deb_usbd(&cardp->udev->dev, "RX URB failed: %d\n",
+				     urb->status);
+			kfree_skb(skb);
+			goto setup_for_next;
+		}
+
+		recvbuff = skb->data;
+		recvtype = le32_to_cpu(pkt[0]);
+		lbtf_deb_usb("Recv length = 0x%x, Recv type = 0x%X",
+					  recvlength, recvtype);
+
+		lbtf_deb_hex(LBTF_DEB_CMD, "CMD Data ", recvbuff, min_t(unsigned int, recvlength, 100));
+
+	} else if (urb->status) {
+		kfree_skb(skb);
+		lbtf_deb_leave(LBTF_DEB_USB);
+		return;
+	}
+
+	if (CMD_TYPE_REQUEST == recvtype) {
+		if (recvlength > LBS_CMD_BUFFER_SIZE) {
+			lbtf_deb_usbd(&cardp->udev->dev,
+					 "The receive buffer is too large\n");
+			kfree_skb(skb);
+			goto setup_for_next;
+		}
+
+		BUG_ON(!in_interrupt());
+
+		cmd = (struct cmd_ds_get_hw_spec *)(recvbuff + MESSAGE_HEADER_LEN);
+
+		switch (le16_to_cpu(cmd->hdr.command)) {
+			case (CMD_GET_HW_SPEC | 0x8000):
+				lbtf_deb_usb("received hw spec reponse");
+
+				/* Process cmd return */
+				cardp->fwcapinfo = le32_to_cpu(cmd->fwcapinfo);
+
+				/* The firmware release is in an interesting format: the patch
+				 * level is in the most significant nibble ... so fix that: */
+				cardp->fwrelease = le32_to_cpu(cmd->fwrelease);
+				cardp->fwrelease = (cardp->fwrelease << 8) |
+					(cardp->fwrelease >> 24 & 0xff);
+
+				printk(KERN_INFO "libertas_tf_usb: %pM, fw %u.%u.%up%u, cap 0x%08x\n",
+					cmd->permanentaddr,
+					cardp->fwrelease >> 24 & 0xff,
+					cardp->fwrelease >> 16 & 0xff,
+					cardp->fwrelease >>  8 & 0xff,
+					cardp->fwrelease       & 0xff,
+					cardp->fwcapinfo);
+				lbtf_deb_usb("GET_HW_SPEC: hardware interface 0x%x, hardware spec 0x%04x\n",
+						cmd->hwifversion, cmd->version);
+
+				memmove(cardp->hw_addr, cmd->permanentaddr, ETH_ALEN);
+
+				cardp->cmdresp = 1;
+				wake_up(&cardp->fw_wq);
+				break;
+
+			case (CMD_SET_BOOT2_VER | 0x8000):
+				lbtf_deb_usb("received boot2 ver reponse");
+				cardp->cmdresp = 1;
+				wake_up(&cardp->fw_wq);
+				break;
+
+			default:
+				lbtf_deb_usb("received unhandled cmd reponse 0x%x",
+				             le16_to_cpu(cmd->hdr.command));
+				break;
+		}
+
+		kfree_skb(skb);
+	} else {
+		lbtf_deb_usbd(&cardp->udev->dev,
+		         "libertastf: unknown command type 0x%X\n", recvtype);
+		kfree_skb(skb);
+	}
+
+
+setup_for_next:
+	if (!cardp->cmdresp)
+		__if_usb_submit_rx_urb(cardp, &if_usb_receive_cmd_response);
+	lbtf_deb_leave(LBTF_DEB_USB);
+}
+
+/**
+ *  if_usb_setup_firmware - Setup firmware by sending boot2 ver command
+ *
+ *  Returns: 0
+ */
+static void if_usb_setup_firmware(struct if_usb_card *cardp)
 {
-	struct if_usb_card *cardp = priv->card;
 	struct cmd_ds_set_boot2_ver b2_cmd;
 
 	lbtf_deb_enter(LBTF_DEB_USB);
 
-	if_usb_submit_rx_urb(cardp);
-	b2_cmd.hdr.size = cpu_to_le16(sizeof(b2_cmd));
+	if (__if_usb_submit_rx_urb(cardp, &if_usb_receive_cmd_response) < 0) {
+		lbtf_deb_usbd(&cardp->udev->dev, "URB submission is failed\n");
+	}
+
+	memset(&b2_cmd, 0, sizeof(struct cmd_ds_set_boot2_ver));
+
+	b2_cmd.hdr.command = cpu_to_le16(CMD_SET_BOOT2_VER);
+	b2_cmd.hdr.size = cpu_to_le16(sizeof(struct cmd_ds_set_boot2_ver));
 	b2_cmd.action = 0;
 	b2_cmd.version = cardp->boot2_version;
 
-	if (lbtf_cmd_with_response(priv, CMD_SET_BOOT2_VER, &b2_cmd))
-		lbtf_deb_usb("Setting boot2 version failed\n");
+	cardp->cmdresp = 0;
+
+	_if_usb_host_to_card(cardp, MVMS_CMD, (uint8_t *)&b2_cmd, sizeof(b2_cmd));
+
+	wait_event_interruptible_timeout(cardp->fw_wq, cardp->cmdresp, 5 * (HZ));
+
+	usb_kill_urb(cardp->rx_urb);
 
 	lbtf_deb_leave(LBTF_DEB_USB);
+	return;
 }
 
 static void if_usb_fw_timeo(unsigned long priv)
@@ -132,6 +257,69 @@
 }
 
 /**
+ *  if_usb_issue_hw_spec_command - Issue hw spec command.
+ *
+ *  Returns: 0
+ */
+static int if_usb_issue_hw_spec_command(struct if_usb_card *cardp)
+{
+	struct cmd_ds_get_hw_spec cmd;
+	lbtf_deb_enter(LBTF_DEB_USB);
+
+	memset(&cmd, 0, sizeof(struct cmd_ds_get_hw_spec));
+	cmd.hdr.command = cpu_to_le16(CMD_GET_HW_SPEC);
+	cmd.hdr.size = cpu_to_le16(sizeof(struct cmd_ds_get_hw_spec));
+	memcpy(cmd.permanentaddr, cardp->hw_addr, ETH_ALEN);
+
+	_if_usb_host_to_card(cardp, MVMS_CMD, (uint8_t *)&cmd, sizeof(cmd));
+
+	lbtf_deb_leave(LBTF_DEB_USB);
+	return 0;
+}
+
+/**
+ *  if_usb_update_hw_spec: Updates the hardware details.
+ *
+ *  @card    	A pointer to card structure
+ *
+ *  Returns: 0 on success, error on failure
+ */
+int if_usb_update_hw_spec(struct if_usb_card *cardp)
+{
+	int ret = -1;
+
+	lbtf_deb_enter(LBTF_DEB_USB);
+
+	if (__if_usb_submit_rx_urb(cardp, &if_usb_receive_cmd_response) < 0) {
+		lbtf_deb_usbd(&cardp->udev->dev, "URB submission is failed\n");
+	}
+
+	/* Send and wait for the response */
+	cardp->cmdresp = 0;
+
+	/* Issue hw spec command */
+	if_usb_issue_hw_spec_command(cardp);
+
+	/* wait for command response */
+	wait_event_interruptible_timeout(cardp->fw_wq, cardp->cmdresp, 5 * (HZ));
+
+	/* Process response */
+	if (cardp->cmdresp) {
+		lbtf_deb_usb("Getting hw spec succeded\n");
+		ret = 0;
+	} else {
+		lbtf_deb_usb("Getting hw spec failed\n");
+		ret = 1;
+	}
+
+	usb_kill_urb(cardp->rx_urb);
+
+	lbtf_deb_leave(LBTF_DEB_USB);
+	return ret;
+}
+
+
+/**
  *  if_usb_probe - sets the configuration values
  *
  *  @ifnum	interface number
@@ -148,6 +336,7 @@
 	struct lbtf_private *priv;
 	struct if_usb_card *cardp;
 	int i;
+	int ret = 0;
 
 	lbtf_deb_enter(LBTF_DEB_USB);
 	udev = interface_to_usbdev(intf);
@@ -178,16 +367,19 @@
 				le16_to_cpu(endpoint->wMaxPacketSize);
 			cardp->ep_in = usb_endpoint_num(endpoint);
 
-			lbtf_deb_usbd(&udev->dev, "in_endpoint = %d\n", cardp->ep_in);
-			lbtf_deb_usbd(&udev->dev, "Bulk in size is %d\n", cardp->ep_in_size);
+			lbtf_deb_usbd(&udev->dev, "in_endpoint = %d\n",
+				cardp->ep_in);
+			lbtf_deb_usbd(&udev->dev, "Bulk in size is %d\n",
+				cardp->ep_in_size);
 		} else if (usb_endpoint_is_bulk_out(endpoint)) {
 			cardp->ep_out_size =
 				le16_to_cpu(endpoint->wMaxPacketSize);
 			cardp->ep_out = usb_endpoint_num(endpoint);
 
-			lbtf_deb_usbd(&udev->dev, "out_endpoint = %d\n", cardp->ep_out);
+			lbtf_deb_usbd(&udev->dev, "out_endpoint = %d\n",
+				cardp->ep_out);
 			lbtf_deb_usbd(&udev->dev, "Bulk out size is %d\n",
-			              cardp->ep_out_size);
+				cardp->ep_out_size);
 		}
 	}
 	if (!cardp->ep_out_size || !cardp->ep_in_size) {
@@ -221,7 +413,33 @@
 		goto dealloc;
 	}
 
-	priv = lbtf_add_card(cardp, &udev->dev);
+	cardp->boot2_version = udev->descriptor.bcdDevice;
+
+	usb_get_dev(udev);
+	usb_set_intfdata(intf, cardp);
+
+	/* Upload firmware */
+	lbtf_deb_usbd(&udev->dev, "Going to upload fw...");
+	if (if_usb_prog_firmware(cardp))
+		goto dealloc;
+
+	if_usb_setup_firmware(cardp);
+
+	/*
+	 * We need to get the hw spec here because we must have the
+	 * MAC address before we call lbtf_add_card
+	 *
+	 * Read priv address from HW
+	 */
+	memset(cardp->hw_addr, 0xff, ETH_ALEN);
+
+	ret = if_usb_update_hw_spec(cardp);
+	if (ret) {
+		ret = -1;
+		pr_err("Error fetching MAC address from hardware.");
+	}
+
+	priv = lbtf_add_card(cardp, &udev->dev, cardp->hw_addr);
 	if (!priv)
 		goto dealloc;
 
@@ -230,10 +448,11 @@
 	priv->hw_host_to_card = if_usb_host_to_card;
 	priv->hw_prog_firmware = if_usb_prog_firmware;
 	priv->hw_reset_device = if_usb_reset_device;
-	cardp->boot2_version = udev->descriptor.bcdDevice;
 
-	usb_get_dev(udev);
-	usb_set_intfdata(intf, cardp);
+	cardp->priv->fw_ready = 1;
+
+	/* "turn on" rx */
+	if_usb_submit_rx_urb(cardp);
 
 	return 0;
 
@@ -318,10 +537,12 @@
 
 	if (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_DATA_TO_RECV)) {
 		lbtf_deb_usb2(&cardp->udev->dev, "There are data to follow\n");
-		lbtf_deb_usb2(&cardp->udev->dev, "seqnum = %d totalbytes = %d\n",
-			     cardp->fwseqnum, cardp->totalbytes);
+		lbtf_deb_usb2(&cardp->udev->dev,
+			"seqnum = %d totalbytes = %d\n",
+			cardp->fwseqnum, cardp->totalbytes);
 	} else if (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_LAST_BLOCK)) {
-		lbtf_deb_usb2(&cardp->udev->dev, "Host has finished FW downloading\n");
+		lbtf_deb_usb2(&cardp->udev->dev,
+			"Host has finished FW downloading\n");
 		lbtf_deb_usb2(&cardp->udev->dev, "Donwloading FW JUMP BLOCK\n");
 
 		/* Host has finished FW downloading
@@ -367,7 +588,7 @@
 /**
  *  usb_tx_block - transfer data to the device
  *
- *  @priv 	pointer to struct lbtf_private
+ *  @priv	pointer to struct lbtf_private
  *  @payload	pointer to payload data
  *  @nb		data length
  *  @data	non-zero for data, zero for commands
@@ -382,9 +603,11 @@
 
 	lbtf_deb_enter(LBTF_DEB_USB);
 	/* check if device is removed */
-	if (cardp->priv->surpriseremoved) {
-		lbtf_deb_usbd(&cardp->udev->dev, "Device removed\n");
-		goto tx_ret;
+	if (cardp->priv) {
+		if (cardp->priv->surpriseremoved) {
+			lbtf_deb_usbd(&cardp->udev->dev, "Device removed\n");
+			goto tx_ret;
+		}
 	}
 
 	if (data)
@@ -400,7 +623,8 @@
 	urb->transfer_flags |= URB_ZERO_PACKET;
 
 	if (usb_submit_urb(urb, GFP_ATOMIC)) {
-		lbtf_deb_usbd(&cardp->udev->dev, "usb_submit_urb failed: %d\n", ret);
+		lbtf_deb_usbd(&cardp->udev->dev,
+			"usb_submit_urb failed: %d\n", ret);
 		goto tx_ret;
 	}
 
@@ -438,10 +662,12 @@
 
 	cardp->rx_urb->transfer_flags |= URB_ZERO_PACKET;
 
-	lbtf_deb_usb2(&cardp->udev->dev, "Pointer for rx_urb %p\n", cardp->rx_urb);
+	lbtf_deb_usb2(&cardp->udev->dev, "Pointer for rx_urb %p\n",
+		cardp->rx_urb);
 	ret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC);
 	if (ret) {
-		lbtf_deb_usbd(&cardp->udev->dev, "Submit Rx URB failed: %d\n", ret);
+		lbtf_deb_usbd(&cardp->udev->dev,
+			"Submit Rx URB failed: %d\n", ret);
 		kfree_skb(skb);
 		cardp->rx_skb = NULL;
 		lbtf_deb_leave(LBTF_DEB_USB);
@@ -522,14 +748,14 @@
 			}
 		} else if (bcmdresp.cmd != BOOT_CMD_FW_BY_USB) {
 			pr_info("boot cmd response cmd_tag error (%d)\n",
-				    bcmdresp.cmd);
+				bcmdresp.cmd);
 		} else if (bcmdresp.result != BOOT_CMD_RESP_OK) {
 			pr_info("boot cmd response result error (%d)\n",
-				    bcmdresp.result);
+				bcmdresp.result);
 		} else {
 			cardp->bootcmdresp = 1;
 			lbtf_deb_usbd(&cardp->udev->dev,
-				     "Received valid boot command response\n");
+				"Received valid boot command response\n");
 		}
 
 		kfree_skb(skb);
@@ -541,19 +767,23 @@
 	syncfwheader = kmemdup(skb->data, sizeof(struct fwsyncheader),
 			       GFP_ATOMIC);
 	if (!syncfwheader) {
-		lbtf_deb_usbd(&cardp->udev->dev, "Failure to allocate syncfwheader\n");
+		lbtf_deb_usbd(&cardp->udev->dev,
+			"Failure to allocate syncfwheader\n");
 		kfree_skb(skb);
 		lbtf_deb_leave(LBTF_DEB_USB);
 		return;
 	}
 
 	if (!syncfwheader->cmd) {
-		lbtf_deb_usb2(&cardp->udev->dev, "FW received Blk with correct CRC\n");
-		lbtf_deb_usb2(&cardp->udev->dev, "FW received Blk seqnum = %d\n",
-			     le32_to_cpu(syncfwheader->seqnum));
+		lbtf_deb_usb2(&cardp->udev->dev,
+			"FW received Blk with correct CRC\n");
+		lbtf_deb_usb2(&cardp->udev->dev,
+			"FW received Blk seqnum = %d\n",
+			le32_to_cpu(syncfwheader->seqnum));
 		cardp->CRC_OK = 1;
 	} else {
-		lbtf_deb_usbd(&cardp->udev->dev, "FW received Blk with CRC error\n");
+		lbtf_deb_usbd(&cardp->udev->dev,
+			"FW received Blk with CRC error\n");
 		cardp->CRC_OK = 0;
 	}
 
@@ -666,7 +896,8 @@
 	{
 		/* Event cause handling */
 		u32 event_cause = le32_to_cpu(pkt[1]);
-		lbtf_deb_usbd(&cardp->udev->dev, "**EVENT** 0x%X\n", event_cause);
+		lbtf_deb_usbd(&cardp->udev->dev, "**EVENT** 0x%X\n",
+			event_cause);
 
 		/* Icky undocumented magic special case */
 		if (event_cause & 0xffff0000) {
@@ -689,7 +920,7 @@
 	}
 	default:
 		lbtf_deb_usbd(&cardp->udev->dev,
-		         "libertastf: unknown command type 0x%X\n", recvtype);
+			"libertastf: unknown command type 0x%X\n", recvtype);
 		kfree_skb(skb);
 		break;
 	}
@@ -700,19 +931,18 @@
 }
 
 /**
- *  if_usb_host_to_card -  Download data to the device
+ *  _if_usb_host_to_card -  Download data to the device
  *
- *  @priv		pointer to struct lbtf_private structure
+ *  @cardp		pointer to struct if_usb_card structure
  *  @type		type of data
  *  @buf		pointer to data buffer
  *  @len		number of bytes
  *
  *  Returns: 0 on success, nonzero otherwise
  */
-static int if_usb_host_to_card(struct lbtf_private *priv, uint8_t type,
+static int _if_usb_host_to_card(struct if_usb_card *cardp, uint8_t type,
 			       uint8_t *payload, uint16_t nb)
 {
-	struct if_usb_card *cardp = priv->card;
 	u8 data = 0;
 
 	lbtf_deb_usbd(&cardp->udev->dev, "*** type = %u\n", type);
@@ -732,6 +962,22 @@
 }
 
 /**
+ *  if_usb_host_to_card -  Download data to the device
+ *
+ *  @priv		pointer to struct lbtf_private structure
+ *  @type		type of data
+ *  @buf		pointer to data buffer
+ *  @len		number of bytes
+ *
+ *  Returns: 0 on success, nonzero otherwise
+ */
+static int if_usb_host_to_card(struct lbtf_private *priv, uint8_t type,
+			       uint8_t *payload, uint16_t nb)
+{
+	return _if_usb_host_to_card(priv->card, type, payload, nb);
+}
+
+/**
  *  if_usb_issue_boot_command - Issue boot command to Boot2.
  *
  *  @ivalue   1 boots from FW by USB-Download, 2 boots from FW in EEPROM.
@@ -866,8 +1112,11 @@
 	if_usb_send_fw_pkt(cardp);
 
 	/* ... and wait for the process to complete */
-	wait_event_interruptible(cardp->fw_wq, cardp->priv->surpriseremoved ||
-					       cardp->fwdnldover);
+	if (cardp->priv)
+		wait_event_interruptible(cardp->fw_wq, cardp->priv->surpriseremoved ||
+							   cardp->fwdnldover);
+	else
+		wait_event_interruptible(cardp->fw_wq, cardp->fwdnldover);
 
 	del_timer_sync(&cardp->fw_timeout);
 	usb_kill_urb(cardp->rx_urb);
@@ -884,14 +1133,13 @@
 		goto release_fw;
 	}
 
-	cardp->priv->fw_ready = 1;
+	if (cardp->priv)
+		cardp->priv->fw_ready = 1;
 
  release_fw:
 	release_firmware(cardp->fw);
 	cardp->fw = NULL;
 
-	if_usb_setup_firmware(cardp->priv);
-
  done:
 	lbtf_deb_leave_args(LBTF_DEB_USB, "ret %d", ret);
 	return ret;
diff -urN git//drivers/net/wireless/libertas_tf/if_usb.h git-mod//drivers/net/wireless/libertas_tf/if_usb.h
--- git//drivers/net/wireless/libertas_tf/if_usb.h	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/if_usb.h	2012-01-31 07:15:13.700705536 +0100
@@ -70,6 +70,11 @@
 	uint8_t fwfinalblk;
 
 	__le16 boot2_version;
+
+	int cmdresp;
+	u8 hw_addr[ETH_ALEN];
+	u32 fwrelease;
+	u32 fwcapinfo;
 };
 
 /** fwheader */
diff -urN git//drivers/net/wireless/libertas_tf/libertas_tf.h git-mod//drivers/net/wireless/libertas_tf/libertas_tf.h
--- git//drivers/net/wireless/libertas_tf/libertas_tf.h	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/libertas_tf.h	2012-01-31 07:15:13.700705536 +0100
@@ -46,6 +46,8 @@
 
 #define CMD_ACT_GET			0x0000
 #define CMD_ACT_SET			0x0001
+#define CMD_ACT_ADD			0x0002
+#define CMD_ACT_REMOVE		0x0004
 
 /* Define action or option for CMD_802_11_RESET */
 #define CMD_ACT_HALT			0x0003
@@ -80,6 +82,7 @@
 	LBTF_PASSIVE_MODE,
 	LBTF_STA_MODE,
 	LBTF_AP_MODE,
+	LBTF_FULLMAC_MODE,
 };
 
 /** Card Event definition */
@@ -103,6 +106,7 @@
 #define LBS_CMD_BUFFER_SIZE             (2 * 1024)
 #define MRVDRV_MAX_CHANNEL_SIZE		14
 #define MRVDRV_SNAP_HEADER_LEN          8
+#define LBS_NUM_BUFFERS				7
 
 #define	LBS_UPLD_SIZE			2312
 #define DEV_NAME_LEN			32
@@ -185,14 +189,20 @@
 	   bit1 1/0=cmd_sent/cmd_tx_done,
 	   all other bits reserved 0 */
 	struct ieee80211_vif *vif;
+	struct ieee80211_vif *sec_vif;  /* only allow a single secondary vif */
+	enum lbtf_mode mode;
 
 	struct work_struct cmd_work;
 	struct work_struct tx_work;
 	/** Hardware access */
 	int (*hw_host_to_card) (struct lbtf_private *priv, u8 type, u8 *payload, u16 nb);
-	int (*hw_prog_firmware) (struct if_usb_card *cardp);
-	int (*hw_reset_device) (struct if_usb_card *cardp);
-
+	int (*hw_prog_firmware) (void *cardp);
+	int (*hw_reset_device) (void *cardp);
+	int (*enter_deep_sleep) (struct lbtf_private *priv);
+	int (*exit_deep_sleep) (struct lbtf_private *priv);
+	int (*reset_deep_sleep_wakeup) (struct lbtf_private *priv);
+	int (*enable_interrupts) (struct lbtf_private *priv);
+	int (*disable_interrupts) (struct lbtf_private *priv);
 
 	/** Wlan adapter data structure*/
 	/** STATUS variables */
@@ -236,6 +246,8 @@
 
 	struct sk_buff *skb_to_tx;
 	struct sk_buff *tx_skb;
+	struct sk_buff *tx_skb_old;
+	struct sk_buff_head tx_skb_buf;
 
 	/** NIC Operation characteristics */
 	u16 mac_control;
@@ -256,6 +268,17 @@
 
 	/* Most recently reported noise in dBm */
 	s8 noise;
+	
+	/* Command responses sent from the hardware to the driver */
+	int cur_cmd_retcode;
+	u8 resp_idx;
+	u8 resp_buf[2][LBS_UPLD_SIZE];
+	u32 resp_len[2];
+	
+	/* beacon status info */
+	bool beacon_enable;
+	u16 beacon_int;
+
 };
 
 /* 802.11-related definitions */
@@ -470,6 +493,8 @@
 void lbtf_set_mode(struct lbtf_private *priv, enum lbtf_mode mode);
 void lbtf_set_bssid(struct lbtf_private *priv, bool activate, const u8 *bssid);
 int lbtf_set_mac_address(struct lbtf_private *priv, uint8_t *mac_addr);
+int lbtf_add_mac_address(struct lbtf_private *priv, uint8_t *mac_addr);
+int lbtf_remove_mac_address(struct lbtf_private *priv, uint8_t *mac_addr);
 
 int lbtf_set_channel(struct lbtf_private *priv, u8 channel);
 
@@ -486,11 +511,11 @@
 /* main.c */
 struct chan_freq_power *lbtf_get_region_cfp_table(u8 region,
 	int *cfp_no);
-struct lbtf_private *lbtf_add_card(void *card, struct device *dmdev);
+struct lbtf_private *lbtf_add_card(void *card, struct device *dmdev, u8 mac_addr[ETH_ALEN]);
 int lbtf_remove_card(struct lbtf_private *priv);
-int lbtf_start_card(struct lbtf_private *priv);
 int lbtf_rx(struct lbtf_private *priv, struct sk_buff *skb);
 void lbtf_send_tx_feedback(struct lbtf_private *priv, u8 retrycnt, u8 fail);
+void lbtf_host_to_card_done(struct lbtf_private *priv );
 void lbtf_bcn_sent(struct lbtf_private *priv);
 
 /* support functions for cmd.c */
diff -urN git//drivers/net/wireless/libertas_tf/main.c git-mod//drivers/net/wireless/libertas_tf/main.c
--- git//drivers/net/wireless/libertas_tf/main.c	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/main.c	2012-01-31 07:15:13.700705536 +0100
@@ -10,14 +10,13 @@
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
 #include <linux/slab.h>
-
 #include <linux/etherdevice.h>
 #include "libertas_tf.h"
 
 #define DRIVER_RELEASE_VERSION "004.p0"
 /* thinfirm version: 5.132.X.pX */
 #define LBTF_FW_VER_MIN		0x05840300
-#define LBTF_FW_VER_MAX		0x0584ffff
+#define LBTF_FW_VER_MAX		0x0900ffff
 #define QOS_CONTROL_LEN		2
 
 /* Module parameters */
@@ -25,6 +24,10 @@
 EXPORT_SYMBOL_GPL(lbtf_debug);
 module_param_named(libertas_tf_debug, lbtf_debug, int, 0644);
 
+unsigned int lbtf_reset_fw;
+EXPORT_SYMBOL_GPL(lbtf_reset_fw);
+module_param_named(libertas_tf_reset_fw, lbtf_reset_fw, int, 0644);
+
 static const char lbtf_driver_version[] = "THINFIRM-USB8388-" DRIVER_RELEASE_VERSION
 #ifdef DEBUG
 	"-dbg"
@@ -147,20 +150,23 @@
 	int ret = -1;
 
 	lbtf_deb_enter(LBTF_DEB_FW);
+
 	/*
 	 * Read priv address from HW
 	 */
 	memset(priv->current_addr, 0xff, ETH_ALEN);
 	ret = lbtf_update_hw_spec(priv);
 	if (ret) {
-		ret = -1;
-		goto done;
+		   ret = -1;
+		   goto done;
 	}
 
 	lbtf_set_mac_control(priv);
 	lbtf_set_radio_control(priv);
+	lbtf_set_mode(priv, LBTF_PASSIVE_MODE);
 
 	ret = 0;
+
 done:
 	lbtf_deb_leave_args(LBTF_DEB_FW, "ret: %d", ret);
 	return ret;
@@ -179,12 +185,12 @@
 	spin_lock_irqsave(&priv->driver_lock, flags);
 
 	if (!priv->cur_cmd) {
-		printk(KERN_DEBUG "libertastf: command timer expired; "
+		printk(KERN_DEBUG "libertas_tf: command timer expired; "
 				  "no pending command\n");
 		goto out;
 	}
 
-	printk(KERN_DEBUG "libertas: command %x timed out\n",
+	printk(KERN_DEBUG "libertas_tf: command %x timed out\n",
 		le16_to_cpu(priv->cur_cmd->cmdbuf->command));
 
 	priv->cmd_timed_out = 1;
@@ -201,6 +207,8 @@
 	mutex_init(&priv->lock);
 
 	priv->vif = NULL;
+	priv->sec_vif = NULL;
+	priv->mode = LBTF_FULLMAC_MODE;
 	setup_timer(&priv->command_timer, command_timer_fn,
 		(unsigned long)priv);
 
@@ -229,6 +237,8 @@
 {
 	struct lbtf_private *priv = hw->priv;
 
+	lbtf_deb_enter(LBTF_DEB_TX);
+
 	priv->skb_to_tx = skb;
 	queue_work(lbtf_wq, &priv->tx_work);
 	/*
@@ -236,6 +246,8 @@
 	 * there are no buffered multicast frames to send
 	 */
 	ieee80211_stop_queues(priv->hw);
+
+	lbtf_deb_leave(LBTF_DEB_TX);
 	return NETDEV_TX_OK;
 }
 
@@ -251,9 +263,20 @@
 
 	lbtf_deb_enter(LBTF_DEB_MACOPS | LBTF_DEB_TX);
 
-	if ((priv->vif->type == NL80211_IFTYPE_AP) &&
-	    (!skb_queue_empty(&priv->bc_ps_buf)))
+	/* Below are some extra debugging prints that normally we don't want */
+	/* Change to 1 to reenable */
+#if 0
+	lbtf_deb_tx("priv: %p", priv);
+	lbtf_deb_tx("priv->vif: %p", priv->vif);
+	lbtf_deb_tx("&(priv->bc_ps_buf): %p", &priv->bc_ps_buf);
+#endif
+
+	if (priv->vif &&
+		 (priv->vif->type == NL80211_IFTYPE_AP) &&
+		 (!skb_queue_empty(&priv->bc_ps_buf))) {
+		lbtf_deb_tx("bc_ps_buf");
 		skb = skb_dequeue(&priv->bc_ps_buf);
+	}
 	else if (priv->skb_to_tx) {
 		skb = priv->skb_to_tx;
 		priv->skb_to_tx = NULL;
@@ -276,22 +299,28 @@
 	/* Activate per-packet rate selection */
 	txpd->tx_control |= cpu_to_le32(MRVL_PER_PACKET_RATE |
 			     ieee80211_get_tx_rate(priv->hw, info)->hw_value);
+	lbtf_deb_tx("tx_control: %x", txpd->tx_control );
 
 	/* copy destination address from 802.11 header */
 	memcpy(txpd->tx_dest_addr_high, skb->data + sizeof(struct txpd) + 4,
 		ETH_ALEN);
 	txpd->tx_packet_length = cpu_to_le16(len);
 	txpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));
-	lbtf_deb_hex(LBTF_DEB_TX, "TX Data", skb->data, min_t(unsigned int, skb->len, 100));
-	BUG_ON(priv->tx_skb);
+
+	lbtf_deb_hex(LBTF_DEB_TX, "TX Data ", skb->data, min_t(unsigned int, skb->len, 100));
+
 	spin_lock_irq(&priv->driver_lock);
-	priv->tx_skb = skb;
+	skb_queue_tail(&priv->tx_skb_buf, skb);
 	err = priv->hw_host_to_card(priv, MVMS_DAT, skb->data, skb->len);
 	spin_unlock_irq(&priv->driver_lock);
 	if (err) {
 		dev_kfree_skb_any(skb);
-		priv->tx_skb = NULL;
+		skb_dequeue_tail(&priv->tx_skb_buf);
 		pr_err("TX error: %d", err);
+	} else {
+		if (LBS_NUM_BUFFERS > skb_queue_len(&priv->tx_skb_buf))
+			ieee80211_wake_queues(priv->hw);
+		lbtf_deb_tx("TX success");
 	}
 	lbtf_deb_leave(LBTF_DEB_MACOPS | LBTF_DEB_TX);
 }
@@ -304,12 +333,24 @@
 
 	lbtf_deb_enter(LBTF_DEB_MACOPS);
 
-	if (!priv->fw_ready)
+	if (!priv->fw_ready) {
+		lbtf_deb_main("Going to upload fw...");
 		/* Upload firmware */
-		if (priv->hw_prog_firmware(card))
-			goto err_prog_firmware;
+		if (priv->hw_prog_firmware) {
+			if (priv->hw_prog_firmware(card))
+				goto err_prog_firmware;
+			else
+				priv->fw_ready = 1;
+		}
+	} else {
+		if (priv->enable_interrupts) {
+			priv->enable_interrupts(priv);
+		}
+		lbtf_deb_main("FW was already ready...");
+	}
 
 	/* poke the firmware */
+	lbtf_deb_main("Poking fw...");
 	priv->capability = WLAN_CAPABILITY_SHORT_PREAMBLE;
 	priv->radioon = RADIO_ON;
 	priv->mac_control = CMD_ACT_MAC_RX_ON | CMD_ACT_MAC_TX_ON;
@@ -323,12 +364,18 @@
 		goto err_prog_firmware;
 	}
 
-	printk(KERN_INFO "libertastf: Marvell WLAN 802.11 thinfirm adapter\n");
+	printk(KERN_INFO "libertas_tf: Marvell WLAN 802.11 thinfirm adapter\n");
+
+	SET_IEEE80211_PERM_ADDR(hw, priv->current_addr);
+
+	ieee80211_wake_queues(priv->hw);
+
 	lbtf_deb_leave(LBTF_DEB_MACOPS);
 	return 0;
 
 err_prog_firmware:
-	priv->hw_reset_device(card);
+	if (priv->hw_reset_device)
+		priv->hw_reset_device(card);
 	lbtf_deb_leave_args(LBTF_DEB_MACOPS, "error programing fw; ret=%d", ret);
 	return ret;
 }
@@ -343,6 +390,8 @@
 
 	lbtf_deb_enter(LBTF_DEB_MACOPS);
 
+	ieee80211_stop_queues(hw);
+
 	/* Flush pending command nodes */
 	spin_lock_irqsave(&priv->driver_lock, flags);
 	list_for_each_entry(cmdnode, &priv->cmdpendingq, list) {
@@ -359,47 +408,128 @@
 	priv->radioon = RADIO_OFF;
 	lbtf_set_radio_control(priv);
 
+	if (priv->disable_interrupts) {
+		priv->disable_interrupts(priv);
+	}
+
 	lbtf_deb_leave(LBTF_DEB_MACOPS);
 }
 
 static int lbtf_op_add_interface(struct ieee80211_hw *hw,
 			struct ieee80211_vif *vif)
 {
+	struct ieee80211_vif **priv_vif = NULL;
+	u8 null_addr[ETH_ALEN] = {0};
 	struct lbtf_private *priv = hw->priv;
 	lbtf_deb_enter(LBTF_DEB_MACOPS);
-	if (priv->vif != NULL)
-		return -EOPNOTSUPP;
+	if (priv->vif != NULL) {
+		lbtf_deb_macops("priv->vif != NULL");
+		if (priv->sec_vif != NULL)
+			return -EOPNOTSUPP;
+		else {
+			/* Check types of primary and secondary vif.  We only support
+			 * simultaneous STA and Mesh vifs
+			 */
+			if (!((priv->vif->type == NL80211_IFTYPE_STATION &&
+			       vif->type == NL80211_IFTYPE_MESH_POINT) ||
+			      (priv->vif->type == NL80211_IFTYPE_MESH_POINT &&
+			       vif->type == NL80211_IFTYPE_STATION)))
+				return -EOPNOTSUPP;
+			else {
+				priv_vif = &priv->sec_vif;
+			}
+		}
+	} else
+		priv_vif = &priv->vif;
 
-	priv->vif = vif;
+	*priv_vif = vif;
 	switch (vif->type) {
 	case NL80211_IFTYPE_MESH_POINT:
 	case NL80211_IFTYPE_AP:
+	case NL80211_IFTYPE_ADHOC:
 		lbtf_set_mode(priv, LBTF_AP_MODE);
 		break;
 	case NL80211_IFTYPE_STATION:
-		lbtf_set_mode(priv, LBTF_STA_MODE);
+		if (priv->mode != LBTF_AP_MODE)
+			lbtf_set_mode(priv, LBTF_STA_MODE);
 		break;
 	default:
-		priv->vif = NULL;
+		*priv_vif = NULL;
+		lbtf_deb_macops("Unsupported interface mode: %d", vif->type);
 		return -EOPNOTSUPP;
 	}
-	lbtf_set_mac_address(priv, (u8 *) vif->addr);
+
+	if (compare_ether_addr(null_addr, vif->addr) != 0) {
+		lbtf_deb_macops("Setting mac addr: %pM\n", vif->addr);
+		if (priv->sec_vif != NULL)
+			lbtf_add_mac_address(priv, (u8 *) vif->addr);
+		else
+			lbtf_set_mac_address(priv, (u8 *) vif->addr);
+	}
+
+
 	lbtf_deb_leave(LBTF_DEB_MACOPS);
 	return 0;
 }
 
+struct ieee80211_vif **_lbtf_choose_vif(struct ieee80211_vif *vif, 
+			struct lbtf_private *priv, struct ieee80211_vif **other_vif)
+{
+	struct ieee80211_vif ** priv_vif = NULL;
+	if (priv->sec_vif != NULL && priv->sec_vif == vif) {
+		priv_vif = &priv->sec_vif;
+		if (other_vif)
+			*other_vif = priv->vif;
+	}
+	else if (priv->vif != NULL && priv->vif == vif) {
+		priv_vif = &priv->vif;
+		if (other_vif)
+			*other_vif = priv->sec_vif;
+	}
+
+	return priv_vif;
+}
+
 static void lbtf_op_remove_interface(struct ieee80211_hw *hw,
 			struct ieee80211_vif *vif)
 {
 	struct lbtf_private *priv = hw->priv;
+	struct ieee80211_vif **priv_vif;
+	struct ieee80211_vif *other_vif;
 	lbtf_deb_enter(LBTF_DEB_MACOPS);
 
-	if (priv->vif->type == NL80211_IFTYPE_AP ||
-	    priv->vif->type == NL80211_IFTYPE_MESH_POINT)
+	if (!(priv_vif = _lbtf_choose_vif(vif, priv,&other_vif))) {
+		lbtf_deb_macops("vif not found\n");
+		return;
+	}
+
+	if ((*priv_vif)->type == NL80211_IFTYPE_AP ||
+	    (*priv_vif)->type == NL80211_IFTYPE_MESH_POINT)
 		lbtf_beacon_ctrl(priv, 0, 0);
-	lbtf_set_mode(priv, LBTF_PASSIVE_MODE);
-	lbtf_set_bssid(priv, 0, NULL);
-	priv->vif = NULL;
+
+	if (other_vif) {
+		switch (other_vif->type) {
+		case NL80211_IFTYPE_MESH_POINT:
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_ADHOC:
+			lbtf_set_mode(priv, LBTF_AP_MODE);
+			lbtf_set_bssid(priv, 0, NULL);
+			break;
+		case NL80211_IFTYPE_STATION:
+			lbtf_set_mode(priv, LBTF_STA_MODE);
+			break;
+		default:
+			lbtf_deb_macops("Unsupported interface mode: %d", other_vif->type);
+		}
+	} else {
+		lbtf_set_mode(priv, LBTF_PASSIVE_MODE);
+		lbtf_set_bssid(priv, 0, NULL);
+	}
+	*priv_vif = NULL;
+
+	if (priv_vif == &priv->sec_vif)
+		lbtf_remove_mac_address(priv, (u8 *) vif->addr);
+
 	lbtf_deb_leave(LBTF_DEB_MACOPS);
 }
 
@@ -424,6 +554,7 @@
 	int i;
 	struct netdev_hw_addr *ha;
 	int mc_count = netdev_hw_addr_list_count(mc_list);
+	lbtf_deb_enter(LBTF_DEB_MACOPS);
 
 	if (!mc_count || mc_count > MRVDRV_MAX_MULTICAST_LIST_SIZE)
 		return mc_count;
@@ -433,6 +564,7 @@
 	netdev_hw_addr_list_for_each(ha, mc_list)
 		memcpy(&priv->multicastlist[i++], ha->addr, ETH_ALEN);
 
+	lbtf_deb_leave_args(LBTF_DEB_MACOPS, "count: %d", mc_count);
 	return mc_count;
 }
 
@@ -451,10 +583,13 @@
 	*new_flags &= SUPPORTED_FIF_FLAGS;
 
 	if (!changed_flags) {
+		lbtf_deb_macops("no flags changed");
 		lbtf_deb_leave(LBTF_DEB_MACOPS);
 		return;
 	}
 
+	lbtf_deb_macops("New flags 0x%x", *new_flags);
+
 	if (*new_flags & (FIF_PROMISC_IN_BSS))
 		priv->mac_control |= CMD_ACT_MAC_PROMISCUOUS_ENABLE;
 	else
@@ -490,17 +625,29 @@
 {
 	struct lbtf_private *priv = hw->priv;
 	struct sk_buff *beacon;
+	struct ieee80211_vif **priv_vif;
+	struct ieee80211_vif *other_vif;
 	lbtf_deb_enter(LBTF_DEB_MACOPS);
 
-	if (changes & (BSS_CHANGED_BEACON | BSS_CHANGED_BEACON_INT)) {
-		switch (priv->vif->type) {
+	if (!(priv_vif = _lbtf_choose_vif(vif, priv, &other_vif))) {
+		lbtf_deb_macops("vif not found\n");
+		return;
+	}
+
+	lbtf_deb_macops("bss info changed: 0x%x", changes);
+	if (changes & (BSS_CHANGED_BEACON | 
+	               BSS_CHANGED_BEACON_INT | 
+	               BSS_CHANGED_BEACON_ENABLED)) {
+		switch (vif->type) {
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_MESH_POINT:
 			beacon = ieee80211_beacon_get(hw, vif);
 			if (beacon) {
 				lbtf_beacon_set(priv, beacon);
 				kfree_skb(beacon);
-				lbtf_beacon_ctrl(priv, 1,
+				priv->beacon_enable = bss_conf->enable_beacon;
+				priv->beacon_int = bss_conf->beacon_int;
+				lbtf_beacon_ctrl(priv, bss_conf->enable_beacon,
 						 bss_conf->beacon_int);
 			}
 			break;
@@ -509,6 +656,21 @@
 		}
 	}
 
+	if (changes & (BSS_CHANGED_BEACON_INT | 
+	               BSS_CHANGED_BEACON_ENABLED)) {
+		switch (vif->type) {
+		case NL80211_IFTYPE_AP:
+		case NL80211_IFTYPE_MESH_POINT:
+				priv->beacon_enable = bss_conf->enable_beacon;
+				priv->beacon_int = bss_conf->beacon_int;
+				lbtf_beacon_ctrl(priv, bss_conf->enable_beacon,
+						 bss_conf->beacon_int);
+			break;
+		default:
+			break;
+		}
+	}
+
 	if (changes & BSS_CHANGED_BSSID) {
 		bool activate = !is_zero_ether_addr(bss_conf->bssid);
 		lbtf_set_bssid(priv, activate, bss_conf->bssid);
@@ -597,7 +759,7 @@
 
 	lbtf_deb_rx("rx data: skb->len-sizeof(RxPd) = %d-%zd = %zd\n",
 	       skb->len, sizeof(struct rxpd), skb->len - sizeof(struct rxpd));
-	lbtf_deb_hex(LBTF_DEB_RX, "RX Data", skb->data,
+	lbtf_deb_hex(LBTF_DEB_RX, "RX Data ", skb->data,
 	             min_t(unsigned int, skb->len, 100));
 
 	ieee80211_rx_irqsafe(priv->hw, skb);
@@ -614,7 +776,7 @@
  *
  *  Returns: pointer to struct lbtf_priv.
  */
-struct lbtf_private *lbtf_add_card(void *card, struct device *dmdev)
+struct lbtf_private *lbtf_add_card(void *card, struct device *dmdev, u8 mac_addr[ETH_ALEN])
 {
 	struct ieee80211_hw *hw;
 	struct lbtf_private *priv = NULL;
@@ -632,6 +794,7 @@
 	priv->hw = hw;
 	priv->card = card;
 	priv->tx_skb = NULL;
+	priv->tx_skb_old = NULL;
 
 	hw->queues = 1;
 	hw->flags = IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING;
@@ -645,13 +808,21 @@
 	hw->wiphy->bands[IEEE80211_BAND_2GHZ] = &priv->band;
 	hw->wiphy->interface_modes =
 		BIT(NL80211_IFTYPE_STATION) |
-		BIT(NL80211_IFTYPE_ADHOC);
+		BIT(NL80211_IFTYPE_ADHOC) |
+		BIT(NL80211_IFTYPE_AP) |
+		BIT(NL80211_IFTYPE_MESH_POINT);
 	skb_queue_head_init(&priv->bc_ps_buf);
+	skb_queue_head_init(&priv->tx_skb_buf);
 
 	SET_IEEE80211_DEV(hw, dmdev);
 
 	INIT_WORK(&priv->cmd_work, lbtf_cmd_work);
 	INIT_WORK(&priv->tx_work, lbtf_tx_work);
+
+	printk(KERN_INFO "libertas_tf: Marvell WLAN 802.11 thinfirm adapter\n");
+
+	SET_IEEE80211_PERM_ADDR(hw, mac_addr);
+
 	if (ieee80211_register_hw(hw))
 		goto err_init_adapter;
 
@@ -668,13 +839,20 @@
 }
 EXPORT_SYMBOL_GPL(lbtf_add_card);
 
-
 int lbtf_remove_card(struct lbtf_private *priv)
 {
+	struct sk_buff *skb = NULL;
 	struct ieee80211_hw *hw = priv->hw;
 
 	lbtf_deb_enter(LBTF_DEB_MAIN);
 
+	ieee80211_stop_queues(priv->hw);
+
+	while (!skb_queue_empty(&priv->tx_skb_buf)) {
+		skb = skb_dequeue(&priv->tx_skb_buf);
+		dev_kfree_skb_any(skb);
+	}
+
 	priv->surpriseremoved = 1;
 	del_timer(&priv->command_timer);
 	lbtf_free_adapter(priv);
@@ -689,38 +867,107 @@
 
 void lbtf_send_tx_feedback(struct lbtf_private *priv, u8 retrycnt, u8 fail)
 {
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(priv->tx_skb);
+	struct ieee80211_tx_info *info;
+	struct sk_buff *skb = NULL;
+	lbtf_deb_enter(LBTF_DEB_MAIN);
+
+	if (!skb_queue_empty(&priv->tx_skb_buf)) {
+		skb = skb_dequeue(&priv->tx_skb_buf);
+	}
+	
+	if(skb == 0) {
+		lbtf_deb_stats("skb is null");
+	} else {
+
+		lbtf_deb_stats("skb is ok");
+
+		info = IEEE80211_SKB_CB(skb);
+		ieee80211_tx_info_clear_status(info);
+		/*
+		 * Commented out, otherwise we never go beyond 1Mbit/s using mac80211
+		 * default pid rc algorithm.
+		 *
+		 * info->status.retry_count = MRVL_DEFAULT_RETRIES - retrycnt;
+		 */
+		if (!(info->flags & IEEE80211_TX_CTL_NO_ACK) && !fail) {
+			info->flags |= IEEE80211_TX_STAT_ACK;
+		}
+		skb_pull(skb, sizeof(struct txpd));
+		ieee80211_tx_status_irqsafe(priv->hw, skb);
+	}
 
-	ieee80211_tx_info_clear_status(info);
-	/*
-	 * Commented out, otherwise we never go beyond 1Mbit/s using mac80211
-	 * default pid rc algorithm.
-	 *
-	 * info->status.retry_count = MRVL_DEFAULT_RETRIES - retrycnt;
-	 */
-	if (!(info->flags & IEEE80211_TX_CTL_NO_ACK) && !fail)
-		info->flags |= IEEE80211_TX_STAT_ACK;
-	skb_pull(priv->tx_skb, sizeof(struct txpd));
-	ieee80211_tx_status_irqsafe(priv->hw, priv->tx_skb);
-	priv->tx_skb = NULL;
 	if (!priv->skb_to_tx && skb_queue_empty(&priv->bc_ps_buf))
 		ieee80211_wake_queues(priv->hw);
 	else
 		queue_work(lbtf_wq, &priv->tx_work);
+
+	lbtf_deb_leave(LBTF_DEB_MAIN);
 }
 EXPORT_SYMBOL_GPL(lbtf_send_tx_feedback);
 
+void lbtf_host_to_card_done(struct lbtf_private *priv )
+{
+	lbtf_deb_enter(LBTF_DEB_MAIN);
+
+	/* Below are some extra debugging prints that normally we don't want */
+	/* Change to 1 to reenable */
+#if 0
+	lbtf_deb_main("priv: %p", priv);
+	lbtf_deb_main("priv->hw: %p", priv->hw);
+	lbtf_deb_main("priv->tx_skb: %p", priv->tx_skb);
+	lbtf_deb_main("priv->skb_to_tx: %p", priv->skb_to_tx);
+#endif
+
+	if (priv->tx_skb) {
+		lbtf_deb_main("Got done on packet.");
+	} else {
+		lbtf_deb_main("Got done on command.");
+	}
+
+	lbtf_deb_leave(LBTF_DEB_MAIN);
+}
+EXPORT_SYMBOL_GPL(lbtf_host_to_card_done);
+
+struct ieee80211_vif **_lbtf_choose_vif_by_type(enum nl80211_iftype type,
+			struct lbtf_private *priv)
+{
+	struct ieee80211_vif ** priv_vif = NULL;
+	if (priv->sec_vif != NULL && priv->sec_vif->type == type)
+		priv_vif = &priv->sec_vif;
+	else if (priv->vif != NULL && priv->vif->type == type)
+		priv_vif = &priv->vif;
+
+	return priv_vif;
+}
+
 void lbtf_bcn_sent(struct lbtf_private *priv)
 {
 	struct sk_buff *skb = NULL;
+	struct ieee80211_vif ** priv_vif = NULL;
 
-	if (priv->vif->type != NL80211_IFTYPE_AP)
+	lbtf_deb_enter(LBTF_DEB_MAIN);
+
+	if (!priv) {
+		lbtf_deb_main("got bcn sent with priv == NULL");
+		return;
+	}
+
+	if (!(priv_vif = _lbtf_choose_vif_by_type(NL80211_IFTYPE_AP, priv))) {
+			if (!(priv_vif = _lbtf_choose_vif_by_type(NL80211_IFTYPE_MESH_POINT, priv))) {
+				lbtf_deb_macops("vif not found\n");
+				return;
+			}
+		return;
+	}
+
+	if ((*priv_vif)->type != NL80211_IFTYPE_AP &&
+		(*priv_vif)->type != NL80211_IFTYPE_MESH_POINT)
 		return;
 
 	if (skb_queue_empty(&priv->bc_ps_buf)) {
 		bool tx_buff_bc = 0;
 
-		while ((skb = ieee80211_get_buffered_bc(priv->hw, priv->vif))) {
+		while ((skb = ieee80211_get_buffered_bc(priv->hw, (*priv_vif)))) {
 			skb_queue_tail(&priv->bc_ps_buf, skb);
 			tx_buff_bc = 1;
 		}
@@ -730,12 +977,15 @@
 		}
 	}
 
-	skb = ieee80211_beacon_get(priv->hw, priv->vif);
+	skb = ieee80211_beacon_get(priv->hw, (*priv_vif));
 
 	if (skb) {
-		lbtf_beacon_set(priv, skb);
+ 		lbtf_beacon_set(priv, skb);
 		kfree_skb(skb);
+ 		lbtf_beacon_ctrl(priv, priv->beacon_enable, priv->beacon_int);
 	}
+
+	lbtf_deb_leave(LBTF_DEB_MAIN);
 }
 EXPORT_SYMBOL_GPL(lbtf_bcn_sent);
 
diff -urN git//drivers/net/wireless/libertas_tf/Makefile git-mod//drivers/net/wireless/libertas_tf/Makefile
--- git//drivers/net/wireless/libertas_tf/Makefile	2012-01-31 07:11:47.804707348 +0100
+++ git-mod//drivers/net/wireless/libertas_tf/Makefile	2012-01-31 07:15:13.700705536 +0100
@@ -1,6 +1,8 @@
 libertas_tf-objs := main.o cmd.o
 
 libertas_tf_usb-objs += if_usb.o
+libertas_tf_sdio-objs += if_sdio.o
 
 obj-$(CONFIG_LIBERTAS_THINFIRM) += libertas_tf.o
 obj-$(CONFIG_LIBERTAS_THINFIRM_USB) += libertas_tf_usb.o
+obj-$(CONFIG_LIBERTAS_THINFIRM_SDIO) += libertas_tf_sdio.o
